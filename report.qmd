---
title: "Visual methods for exploring multivariate spatio-temporal networks with application to health transport"
subtitle: "Confirmation Report"
author: 
  - "Krisanat Anukarnsakulchularp"
  - "Advisors: Dr. Michael Lydeamore and Prof. Dianne Cook"
format: 
  html:
    toc: true
    embed-resources: true
css: "styles.css"
bibliography: report.bib
---

```{r}
#| message: false
#| echo: false
#| warning: false

# library
library(tidyverse)
library(ggplot2)
library(tidygraph)
library(ggraph)
library(sfnetworks)
library(sf)
library(ggiraph)
library(tsibble)
library(gghighlight)

theme_set(
  theme_minimal()
)

options(scipen = 999)
```

```{r}
#| output: false
#| echo: false

# read data
address <- read_csv(here::here("data/ambulance/hospital_address.csv"))

hos_list <- read_csv(here::here("data/ambulance/Hospital_list.csv")) |>
  janitor::clean_names() |>
  rename(name = other_name) |>
  mutate(name = toupper(name))

patient <- read_csv(here::here("data/ambulance/patient_clean.csv")) |>
  select(!c(...1, ...2)) |>
  mutate(routine = ifelse(routine == 1, "Scheduled", "Emergency")) |>
  filter(iht != 1)

racf <- read_csv(here::here("data/ambulance/RACF_address.csv"))

transfers <- read_csv(here::here("data/ambulance/transfers_all.csv")) |>
  select(!...1)

vic_map <- read_sf(here::here("data/map/LGA_2025_AUST_GDA2020/LGA_2025_AUST_GDA2020.shp")) |>
  filter(STE_NAME21 == "Victoria")
```

```{r}
#| echo: false
racf_location <- transfers |>
  select(sceneaddress, long_racf, lat_racf) |>
  distinct() |>
  rename(long = long_racf,
         lat = lat_racf,
         name = sceneaddress) |> 
  mutate(type = "racf")

hospital_location <- transfers |>
  select(hospitalname, long_hosp, lat_hosp) |>
  distinct() |>
  rename(long = long_hosp,
         lat = lat_hosp,
         name = hospitalname) |> 
  mutate(type = "hospital")

full_location <- bind_rows(racf_location, hospital_location)

simple_graph <- transfers |>
  rename(from = sceneaddress,
         to = hospitalname) |>
  as_tbl_graph() |>
  left_join(full_location, by = "name") |>
  mutate(category = ifelse(name %in% transfers$sceneaddress, "racf", "hospital"))
```

# Background {#sec-background}

Analysing spatio-temporal network data is a contemporary research problem that has gained increasing interest in the health field, particularly within emergency medical services (EMS) and ambulance transfer systems.Â Such data capture spatial, temporal, and often multivariate information. The spatial component generally represents geographic locations or spatial geometries, while the temporal component records time-related information through timestamps or time intervals [@rao2012spatiotemporal]. In addition, the underlying network structure creates connections and multivariate dependencies between locations and transfers. While techniques exist to analyse spatial and temporal components separately, performing analysis, and perhaps more importantly, exploring these components in conjunction with the network structure, remains an open challenge.

Older individuals often require continuous support, including 24-hour care, assistance with daily tasks, and ongoing medical supervision. Thus, many reside in the residential aged care facilities (RACFs), which are specifically designed to provide this comprehensive care [@kearney2006nearby]. RACFs frequently rely on the ambulance services to facilitate the transfers of an individual to the hospital for both acute emergencies and planned/scheduled medical appointments. This rise in the number of transfers is partly due to population ageing [@harris2018estimating], which puts incredible pressure on emergency medical services, where delay could lead to an increase in health risk [@harmsen2015influence]. During the COVID-19 pandemic, lockdown measures and movement restrictions further disrupted the delivery of emergency services. The effects of lockdowns and rising transfer demand highlight the need for further analysis to improve the planning and utilisation of ambulance services.

The ambulance transfer data was provided by Ambulance Victoria. The dataset included the following aspects: spatial, temporal, and multivariate information on each transfer. The spatial information covers the location of the aged care facilities and the hospital (destination) in latitude and longitude. The temporal data provides the date of the transfers, and the multivariate information covers hospitals, aged care facilities, and patient-level details.

To gain insight into transfer patterns, data exploration using network representations linking RACFs and hospitals provides a powerful framework. However, most network research focuses primarily on topological properties, often treating the entire network homogeneously and overlooking other important information, such as the association between variables [@cardenas2021spatio; @fernandez2017influence]. While network representation is suited to transfer data, overemphasising network topology can neglect the fundamental principles of data exploration. These limitations arise from the practical challenges of working with spatio-temporal network data, including data cleaning methods, particularly temporal information, the ease of data wrangling and subsetting, and the challenges of visualisation and inference. As a result, simple informative analyses, such as examining variable distributions, temporal trends, or bivariate relationships, are often underutilised, despite the ability to reveal key insights of the data. This underlines the need for an infrastructure that integrates network-based approaches with exploratory data analysis (EDA), enabling a comprehensive exploration of spatio-temporal transfer networks.

Studying how infectious diseases spread throughout the network (transfer between RACFs and hospitals) is important because the older population tend to face a higher risk of mortality during the outbreaks [@parohan2020risk]. These patient transfers between facilities create ways for the disease to be transmitted across the systems, leading to rapid spread. Traditional compartmental infectious disease models assuming homogeneous or static structure do not adequately capture networks that change over time. In reality, ambulance transfers are highly dynamic, where these connections between facilities can change in response to the demand, constraints, and even outbreak conditions. Understanding these transmission dynamics is therefore crucial for devising effective policies to limit spread as well as identify high-risk facilities, critical transfer connections, and exposed periods.


# Project 1: Developing Infrastructure for Exploratory Analysis of Multivariate Spatio-temporal Network with Applications to Ambulance Transfers

## Part A: Exploratory Data Analysis Infrastructure for Multivariate Spatio-temporal Network

Multivariate spatio-temporal network data has space, time, multiple variables, associations between different locations (which define the network), and multiple types of relationships (hospital to hospital or aged care to hospital, etc.) As these data become more accessible and complex, understanding their structure and dynamics is key to effective decision-making. A major challenge in analysing this data lies in the sheer amount of information it contains most of which is often overlooked due to the difficulty of switching between these dimensions. This infrastructure aims to support the exploration of multivariate spatio-temporal network data. The exploratory data analysis involves several key processes: data storage, cleaning, subsetting, and visualisation. The following section, therefore, reviews existing tools that support these processes and discusses their limitations.


### Data Storage and Cleaning {#sec-storage}

Data cleaning is the first stage of a reliable analysis. Spatio-temporal data usually need to be checked for inconsistency of the temporal records, duplicated records, and spatial inaccuracies. Now, adding the network structure on top of that, such as nodes, edges, and their attributes, requires preserving the relational structure of the network and the spatio-temporal context together throughout the process. Typically, this stage involves tools such as `dplyr` [@dplyr] for manipulating the data, `tsibble` [@tsibble] for validating the temporal inconsistency, `sf` [@sf] for checking the coordinate inaccuracies, and `igraph`/`network` [@igraph; @network] for keeping the network structure.

The `tidygraph` [@tidygraph] package provides a tidy API for graph and network manipulation, where network data is thought of as two tidy tables, one for node and one for edge data. In tidy data [@tidy-data], each variable has its own column, each observation has its own row, and each value has its own cell. These tables are then stored together within a `tbl_graph` object, which preserves the underlying network topology while allowing standard `dplyr` verbs to be applied. The interaction between node and edge tables is done through the use of a special function, `activate()`, which allows the user to switch between the two tables and apply `dplyr` operations such as `mutate()`, `group_by()`, and join operations as shown in @lst-graphcreation.

There are two main functions for creating `tbl_graph` object, `as_tbl_graph()` and `tbl_graph()`. The first function `as_tbl_graph()` takes in a different class of objects, such as `data.frame`, `igraph`, and `network`, then turns it into a `tbl_graph` object. While `tbl_graph()` takes in two `data.frame` objects, one for node and one for edge.

From @lst-graphcreation, the difference between these two methods is that for the `as_tbl_graph()` function, it only needs the edges dataset, which means that all the multivariate information will only be on edge data and in the node data, it will only have the name (location). For the `tbl_graph()` function, the node variable can be explicitly stated, which can come in handy when there are attributes on the node dataset.

```{r}
#| echo: false
racf_nodes <- transfers |> 
  distinct(sceneaddress, long_racf, lat_racf) |>
  rename(name = sceneaddress,
         longitude = long_racf,
         latitude = lat_racf) |> 
  mutate(type = "racf")

hospital_nodes <- transfers |>
  distinct(hospitalname, long_hosp, lat_hosp) |>
  rename(name = hospitalname,
         longitude = long_hosp,
         latitude = lat_hosp) |>
  mutate(type = "hospital")

nodes <- bind_rows(racf_nodes, hospital_nodes)

edges <- patient |>
  rename(from = sceneaddress,
         to = hospitalname) |>
  select(from, to, casedate, age, gender, diagnosis, daytype, single_id)

graph <- tbl_graph(nodes, edges) |>
  activate(edges) |>
  mutate(year = lubridate::year(casedate))
```

```{r}
#| eval: false
#| lst-label: lst-graphcreation
#| lst-cap: "A function for creating a tbl_graph object. There are two main ways: first, using the edge list and second, using node and edge tables. The dplyr function will work normally, like it is on a tibble object, but requires an activate() function to switch between the two tables (node and edge)."
as_tbl_graph(edges)

tbl_graph(nodes, edges)

graph |>
  activate(edges) |>
  mutate(year = lubridate::year(casedate))
```

```{r}
#| echo: false
tbl_graph(nodes, edges) |>
  activate(edges) |>
  mutate(year = lubridate::year(casedate))
```

For spatial networks, the `sfnetworks` package [@sfnetworks] extends `tidygraph` by allowing spatial geometries to be incorporated directly within the `tbl_graph` object. It is useful for dealing with complex geometry where edges are not straight-line connections, such as road or transport networks. The package also allows for the standard spatial operation within the `sf` package to be performed within the network context. 

However, the `tidygraph` object does not provide direct support for time. It would be desirable to use a `tsibble` object as an edge table, which would allow temporal checks, including checking time intervals and missing values. However, in the current framework, these checks have to be performed prior to the creation of the `tbl_graph`. It introduces an important limitation, where common operations such as filling missing observations are done outside the network context and are therefore error prone, and require maintenance of multiple objects.

A basic requirement in cleaning temporal network data is the ability to check whether both nodes exist for a given edge at a specific time. In the case of a missing node, how should the edges associated with that node be imputed? A possible solution is to assume that no edges exist during that period, which may be reasonable in some cases but not in others. It highlights a key challenge in cleaning spatio-temporal network data, where temporal consistency and network structure should be considered jointly. Addressing these requires an object to ensure that both temporal attributes and the relational structure of the network remain coherent throughout the cleaning process.


### Data Subsetting {#sec-datasubsetting}

Data subsetting is used to extract a subset of spatio-temporal network data based on spatial, temporal, and multivariate variables. It includes grouping data by time periods or regions, as well as filtering based on variable values and network characteristics (e.g., in-degree). Subsetting is particularly useful for in-depth analysis, where it may need data from all RACFs within a certain distance of a particular hospital or transfers occurring during the weekends.

In a network context, filtering operations need to account for topological dependencies between nodes and edges. When nodes are removed based on a condition, all edges incident to those nodes are also deleted (@fig-node-filter). In contrast, when edges are removed, the nodes connected to those edges are preserved, since nodes can exist independently from an edge (@fig-edge-filter). The data subsetting is currently well-handled by the `tidygraph` package. The `tbl_graph` object supports these subsetting operations through the use of `dplyr` functions such as `filter()` and `select()`, illustrated in @lst-filtering, which are applied separately on nodes and edges while maintaining the condition of the underlying network. Similarly to the data manipulation, users will need to switch between the node and edge tables to subset based on their attributes.

```{r}
#| lst-label: lst-filtering
#| lst-cap: "A filtering method in tidygraph, where the activate() function allows the user to switch between the node and edge tables."
graph |>
  activate(edges) |>
  filter(between(year, 2020, 2021))
```

```{r}
#| echo: false
nodes_example <- tibble(name = c(1, 2, 3, 4, 5),
                        x = c(1, 1.5, 2, 2, 3),
                        y = c(2, 1, 2, 3, 1))

edges_example <- tibble(from = c(1, 1, 2, 3, 3),
                        to = c(2, 3, 3, 4, 5))

graph_example <- tbl_graph(nodes = nodes_example, edges = edges_example, directed = FALSE)
```

```{r}
#| label: fig-node-filter
#| layout-ncol: 3
#| echo: false
#| fig-cap: "An illustration of node filtering, such as can be done in tidygraph. The selection of a node can be made based on variables such as the facility type (RACF or Hospital). When a node gets filtered out, edges incident to it will also disappear."
#| fig-subcap:
#|  - "Full network"
#|  - "Node to remove"
#|  - "Filtered network"

graph_example |> 
  ggraph(x = x, y = y) + 
  geom_edge_link() +
  geom_node_point(size = 10, color = "blue")

graph_example |> 
  mutate(check = as.factor(ifelse(name == "5", 1, 0))) |> 
  ggraph(x = x, y = y) +
  geom_edge_link() +
  geom_node_point(aes(color = check), size = 10) +
  scale_color_manual(values = c("blue", "red")) +
  theme(legend.position = "none")
  
graph_example |> 
  mutate(check = as.factor(ifelse(name == "5", 1, 0))) |> 
  activate(edges) |> 
  mutate(check = as.factor(ifelse(to == "5", 1, 0))) |> 
  ggraph(x = x, y = y) +
  geom_edge_link(aes(color = check)) +
  geom_node_point(aes(color = check), size = 10) +
  scale_color_manual(values = c("blue", "white")) +
  scale_edge_color_manual(values = c("black", "white")) +
  theme(legend.position = "none")
```

```{r}
#| label: fig-edge-filter
#| layout-ncol: 3
#| echo: false
#| fig-cap: "An illustration of edge filtering, such as can be done in tidygraph. The selection of an edge can be made based on variables such as the transfer weekend. When an edge gets filtered out, nodes incident to it will still be kept."
#| fig-subcap:
#|  - "Full network"
#|  - "Edges to remove"
#|  - "Filtered network"

graph_example |> 
  ggraph(x = x, y = y) + 
  geom_edge_link(color = "blue") +
  geom_node_point(size = 10)

graph_example |> 
  activate(edges) |> 
  mutate(check = as.factor(ifelse(to %in% c("4", "5"), 1, 0))) |> 
  ggraph(x = x, y = y) +
  geom_edge_link(aes(color = check)) +
  geom_node_point(size = 10) +
  scale_color_manual(values = c("blue", "red")) +
  scale_edge_color_manual(values = c("blue", "red")) +
  theme(legend.position = "none")

graph_example |> 
  activate(edges) |> 
  mutate(check = as.factor(ifelse(to %in% c("4", "5"), 1, 0))) |> 
  filter(check != 1) |> 
  ggraph(x = x, y = y) +
  geom_edge_link(color = "blue") +
  geom_node_point(size = 10) +
  theme(legend.position = "none")
```


### Network Sampling

Another important aspect of subsetting is understanding how sampling methods perform on network data. Observational data are often not evenly distributed across multiple dimensions such as time, space, or variable groups. Some strata may contain more observations than others, and analysing these can directly impact the interpretation, as the larger group of strata may dominate the patterns seen. Sampling provides a way to subset the data while keeping it representative of the population. Stratified sampling, in particular, helps with an imbalance case by dividing the data into subgroups and sampling within each group, ensuring that all groups are represented in the sampled data.

```{r}
#| echo: false
nodes_example <- tibble(name = c(1, 2, 3, 4, 5),
                        x = c(1, 1.5, 2, 2, 3),
                        y = c(2, 1, 2, 3, 1))

edges_example <- tibble(from = c(rep(1, 10), rep(1, 2), rep(2, 7), rep(3, 4), rep(3, 1)),
                        to = c(rep(2, 10), rep(3, 2), rep(3, 7), rep(4, 4), rep(5, 1))) |> 
  mutate(id = row_number())

graph_example <- tbl_graph(nodes = nodes_example, edges = edges_example, directed = FALSE)
```


In the network context, sampling methods are generally categorised into the following [@chuong2025network]:

  - **Node-based sampling** selects a subset of nodes from the network and retains edges that are incident to the sampled nodes. This method is efficient and is usually implemented in large-scale studies [@ben2022sampling]. It often fails to capture important global structural properties such as connectivity and clustering.

  - **Edge-based sampling** samples a subset of edges directly and includes the nodes incident to those edges. This method is better at preserving structural pattern [@jiao2024sampling]. However, it may introduce bias towards selecting nodes with higher degrees, resulting in biased sampled data.

There are many additional methods for sampling. @hu2013survey provides a comprehensive survey and taxonomy of graph sampling approaches, which are outside the scope of this project.

```{r}
#| label: fig-edge-sampling
#| layout-ncol: 3
#| echo: false
#| message: false
#| fig-cap: "An illustration of edge-based sampling, such as can be done in tidygraph. The edges set will get sampled, then only include the nodes incident to those edges. This method will be biased towards selecting nodes with higher degrees."
#| fig-subcap:
#|  - "Full network"
#|  - "Sampled edge"
#|  - "Sampled network"
set.seed(1)

graph_example |> 
  ggraph(x = x, y = y) + 
  geom_edge_fan(strength = 1.4) +
  geom_node_point(size = 10)

sample <- graph_example |> 
  activate(edges) |> 
  sample_n(size = 10)

edge_list <- sample |> 
  pull(id)

node_list <- sample |> 
  activate(nodes) |> 
  filter(!node_is_isolated()) |>
  pull(name)

graph_example |> 
  activate(edges) |> 
  mutate(check = as.factor(ifelse(id %in% edge_list, 1, 0))) |> 
  activate(nodes) |> 
  mutate(check = as.factor(ifelse(name %in% node_list, 1, 0))) |> 
  ggraph(x = x, y = y) +
  geom_edge_fan(aes(color = check), strength = 1.4) +
  geom_node_point(color = "black", size = 10) +
  scale_edge_color_manual(values = c("black", "blue")) +
  theme(legend.position = "none")

graph_example |> 
  activate(edges) |> 
  mutate(check = as.factor(ifelse(id %in% edge_list, 1, 0))) |> 
  activate(nodes) |> 
  mutate(check = as.factor(ifelse(name %in% node_list, 1, 0))) |> 
  ggraph(x = x, y = y) +
  geom_edge_fan(aes(color = check), strength = 1.4) +
  geom_node_point(aes(color = check), size = 10) +
  scale_color_manual(values = c("white", "blue")) +
  scale_edge_color_manual(values = c("white", "blue")) +
  theme(legend.position = "none")
```

The `tidygraph` package provides a method for sampling the data for a `tbl_graph` object through a `sample_n()` function. A further limitation of the `tbl_graph` is that it does not directly support stratified (i.e., `group_by`) sampling. Instead, the `tbl_graph` object needs to be converted back to `tibble` [@tibble], performing stratified sampling on the node or edge table, and then filtering the original network based on the sampled nodes or edges (@lst-edgesampling). This limitation shows that sampling operations for network objects can still be improved.

```{r}
#| message: false
#| eval: false
#| lst-label: lst-edgesampling
#| lst-cap: "A code comparison between sampling and stratified sampling on edges. The tidygraph supports edge sampling using the sample_n() function, but with stratified sampling, it does not. This makes it much harder to code stratified sampling."
set.seed(1)

# Edges sampling
graph |> 
  activate(edges) |> 
  sample_n(size = 20) |> 
  activate(nodes) |> 
  filter(!node_is_isolated())

# Stratified edges sampling
edges_kept <- graph |> 
  activate(edges) |> 
  as_tibble() |> 
  group_by(daytype) |> 
  sample_n(size = 10) |> 
  pull(single_id)

graph |> 
  activate(edges) |> 
  filter(single_id %in% edges_kept) |> 
  activate(nodes) |> 
  filter(!node_is_isolated())
```

```{r}
#| echo: false

edges_kept <- graph |>
  activate(edges) |>
  as_tibble() |>
  group_by(daytype) |>
  sample_n(size = 10) |>
  pull(single_id)

graph |>
  activate(edges) |>
  filter(single_id %in% edges_kept) |>
  activate(nodes) |>
  filter(!node_is_isolated())
```

The edge-based sampling method will only retain the nodes that are incident to the sampled edges (@fig-edge-sampling). However, nodes can exist independently without any incident edges, which is what `tidygraph` does for sampling, as discussed in @sec-datasubsetting. To remove such isolated nodes, they must be explicitly filtered from the node table using the `node_is_isolated()` function. It is also worth mentioning that retaining all nodes, including the isolated ones, after the edge-sampling is possible and is, in fact, the default behaviour in `tidygraph`.


### Data visualisation {#sec-visualisation}

Data visualisation helps reveal patterns, anomalies and relationships that may not be apparent from numerical summaries alone. Network data is often viewed as connections or flows between nodes/locations, and network-based visualisation allows for easier communication to a broader audience. For a simple network without spatial coordinates, placing nodes and edges in a visualisation requires the use of a graph layout algorithm, such as the Kamada-Kawai layout [@kk]. Depending on the chosen algorithm, the positions of nodes and edges can be different even on the same network dataset. With spatial information, visualising these becomes more straightforward, as longitude and latitude can be used to specify the actual location of the nodes, with edges represented as lines connecting these locations. 

Visualising multivariate spatio-temporal network data can be challenging. When spatial information is available, the decision to incorporate it into the visualisation is important. On one hand, spatial information allows nodes to be mapped to geographic space, making it easier to infer where nodes are located. On the other hand, omitting spatial information can help reveal non-spatial patterns in the network. Other problems arise when data are highly concentrated in urban areas, making it hard to perceive patterns, or when temporal information is added. A common approach for handling time is facetting, but comparing them requires many back-and-forths. Another possible solution is to animate the network visualisation.

```{r}
#| label: fig-static-network
#| fig-cap: "An ambulance transfer network in Victoria between residential aged care facilities and hospitals. The nodes are mapped to the spatial location (latitude and longitude), while edges are the connections between nodes. It can be difficult to observe patterns, since most of the nodes are located within the Melbourne area."
#| code-summary: "Visualisation"

simple_graph |> 
  ggraph(x = long, y = lat) +
  geom_sf(data = vic_map, color = "white") +
  geom_edge_link(alpha = 0.1) +
  geom_node_point(aes(color = category)) +
  scale_color_brewer(name = "Facility", palette = "Set1")
```

The main limitation of static network visualisation is the restricted amount of information that can be shown in a single figure. The current tool for network visualisation in R is the `ggraph` package [@ggraph], which extends the `ggplot2` package [@ggplot2] to support relational data structures such as networks, graphs, and trees. The `ggraph` package is effective at visualising static networks, offering a range of layout algorithms for placing the node locations while keeping the same familiar `ggplot2` syntax. The support for interactive network visualisation with `ggraph` is currently limited. The reason static network visualisation is hard is that the amount of information that can be mapped to the visualisation is limited within a single figure. As shown in @fig-static-network, just a simple network representation can already become cluttered quickly. Answering detailed questions such as the number of transfers between a specific RACF and Hospital, or the name of a particular RACF, is difficult using static visualisation alone. Interactive visualisation helps with these limitations by layering additional information onto the visualisation, allowing for further exploration.

```{r}
#| label: fig-interact-network
#| fig-cap: "An interactive ambulance transfer network in Victoria between residential aged care facilities and hospitals. The extra information added to the nodes is the location name, and for edges, the number of transfers. This information will be visible when hovering over the node or edge. Using interactive makes it easier to explore the network without adding too much information to the plot."
#| lst-label: lst-interactivevis
#| lst-cap: "Code for creating an interactive network visualisation. Instead of using the ggraph function, such as geom_node_point() and geom_edge_line, geom_point_interactive and geom_segment_interactive are used. The implementation is more complex than necessary because the layout information is not easily accessible."
#| code-summary: "Visualisation"
interactive_vis <- simple_graph |>
  mutate(name = str_remove(name, "'")) |>
  ggraph(x = long, y = lat) +
  geom_sf(data = vic_map, color = "white") +
  geom_segment_interactive(
    data = simple_graph |> 
      activate(edges) |> 
      as_tibble() |> 
      mutate(id = row_number()),
    alpha = 0.2,
    aes(x = long_racf,
        y = lat_racf,
        xend = long_hosp,
        yend = lat_hosp,
        tooltip = weight,
        data_id = id)) +
  geom_point_interactive(aes(x = x,
                             y = y,
                             color = category,
                             tooltip = name,
                             data_id = name)) +
  scale_color_brewer(name = "Facility", palette = "Set1")

girafe(ggobj = interactive_vis,
       options = list(
         opts_hover(
           css = "fill:lightblue;stroke:grey;stroke-width:0.5px"
           ),
         opts_zoom(min = 0.5, max = 3)
       ))
```

The `ggiraph` package [@ggiraph] provides an interactive element to the visualisation through the `ggplot2` extension. Creating interactive network visualisations, therefore, typically requires combining `ggraph` for layout construction with `ggiraph` for interactivity. Getting this to work together requires an insight into how `ggraph` works, which is not a seamless implementation. For example, `ggraph` provides `geom_node_*` and `geom_edge_*` functions for nodes and edges geometry, respectively, but these do not natively support interactivity. To make nodes interactive, `geom_point_interactive()` needs to be used instead of `geom_node_point()`. Making edges interactive is more complex as it requires the use of `geom_segment_interactive()` and mapping the start and end coordinates (`x`, `y`, `xend`, `yend`) for each edge (@lst-interactivevis). By that point, if both node and edge need interactivity, then `ggraph` is not needed, and instead the node and edge can be treated as a different dataset and implement geom_point and geom_segment for drawing the node and edge.


### Next steps

  - The temporal data are not easy to clean currently with `tidygraph`. As a result, issues such as filling missing timestamps and handling inconsistent time periods are currently handled outside the network context, which may affect the network's validity. Therefore, the new data object needs to integrate temporal and network topology jointly.

  - The current data sampling method is limited, with most methods working outside the `tidygraph` object. Although many tools already work with `tibble`, its functionality requires writing a method for `tbl_graph` because `tidygraph` converts `igraph` into `tibble`. Therefore, the new data object should be built on top of `tibble`.

  - Data visualisation capabilities are constrained by the `ggraph` package, as layout calculations are handled internally, making it difficult to access and reuse layout information when extending the visualisation method (e.g., interactive visualisation). Therefore, the new data object will be designed to work directly with the `ggplot2` package for better expansion and application of additional geoms for network visualisation.

  - The work will result in an R package that provides a data object that better encapsulates the spatio-temporal network structure, along with the necessary functionality. It will be designed to work with a tidyverse suite. This is expected to be written into a publishable paper.


## Part B: An Exploratory Analysis of Ambulance Transfer in Victoria

Ambulance and emergency medical services play a critical role in transferring older individuals from residential aged care facilities (RACFs) to hospitals. These transfers form links between RACFs and hospitals across space and time, and are associated with multiple variables such as age, sex, and reason of transfer. Exploratory analysis provides an initial step in examining ambulance transfer data by revealing patterns, anomalies, and relationships. This data can be represented as a multivariate spatio-temporal network, where facilities are represented as nodes and ambulance transfers as time-varying edges.

During the COVID-19 pandemic, government-imposed lockdowns created significant challenges for ambulance services. Previous studies have shown that the pandemic affected the transfer of older individuals from residential aged care facilities to hospitals [@wyer2024impact; @nair2023monitoring; @botan2023pp63]. These restrictions limited ambulance availability and highlighted potential vulnerabilities in the reliance on ambulance transfers for aged care residents. Examining ambulance efficiency and transfer volumes during lockdown periods can inform strategies to improve system resilience and preparedness for future emergencies.


### Transfer distance {#sec-transferdist}

To quantify the ambulance transfer, instead of just looking at the number of transfers, the distance travelled from the aged care facilities to the hospital is considered. The Euclidean distance will be used to calculate a transfer distance. It is the shortest distance between two points based on the latitude and longitude. This measure should give a reasonable estimate for less computing compared to the actual road distance. Note that the limitation is that it ignores the actual street network distance, which is not a straight line, and therefore, the distance between the RACF and the hospital will generally be longer.


```{r}
#| code-summary: "Calculate distance"
#| echo: false
racf_sf <- patient |> 
  select(-c(hospitalname, long_hosp, lat_hosp)) |> 
  st_as_sf(coords = c("long_racf", "lat_racf"), crs = st_crs(4326)) |> 
  rename(geometry_racf = geometry)

hosp_sf <- patient |> 
  select(hospitalname, long_hosp, lat_hosp) |> 
  st_as_sf(coords = c("long_hosp", "lat_hosp"), crs = st_crs(4326)) |> 
  rename(geometry_hosp = geometry)

patient_dist <- bind_cols(racf_sf, hosp_sf) |> 
  mutate(distance = st_distance(geometry_racf, geometry_hosp, by_element = TRUE),
         distance = as.double(distance))
```

```{r}
#| code-summary: "Visualisation"
#| label: fig-distance-dis
#| echo: false
#| fig-cap: "Histogram of ambulance transfer distances for emergency and scheduled cases, with the median indicated by the blue line and the first and third quartiles shown in red. The distributions for emergency and scheduled transfers are similar, with no large difference between the two groups."

patient_dist |>
  group_by(routine) |> 
  mutate(median = median(distance + 1),
         q1 = quantile(distance + 1, probs = 0.25),
         q3 = quantile(distance + 1, probs = 0.75)) |> 
  ggplot(aes(x = distance + 1)) +
  geom_histogram(bins = 45) +
  facet_wrap(~routine, scales = "free_y", ncol = 1) +
  scale_x_log10() +
  geom_vline(aes(xintercept = median), color = "blue") +
  geom_vline(aes(xintercept = q1), color = "red") +
  geom_vline(aes(xintercept = q3), color = "red") +
  labs(y = "Count", x = "Distance (log-scale)")
```

```{r}
#| echo: false

dist_dis <- patient_dist |>
  filter(distance != 0) |>
  pull(distance)
```

From @fig-distance-dis, the median is lower for the emergency transfer compared to scheduled transfers, but not much difference in terms of their distribution. However, there are transfers with zero distance in the data, which might suggest either a data entry error or that the aged care facilities and hospitals are co-located (i.e., located next to each other). In the latter case, this might suggest that the transfer may not be necessary. After filtering the distance data to zero and going through them manually, it can be seen that the aged care facility and hospital are indeed in the same location.

Generally, transfers of the patient should be done quickly, which means sending them to the closest hospital available. It could also explain why some RACFs have a zero transfer distance. Though when the co-located hospital cannot handle emergency cases, the ambulance will need to transfer patients to the nearest hospital with an emergency department. It can be verified using the hospital data, which includes a column indicating whether the hospital has an emergency department. To further analyse this, the distances will be calculated between RACFs and hospitals across all possible combinations to identify which RACFs are located next to hospitals. After the calculation, the RACFs will be categorised into two groups: RACFs close to hospitals and those otherwise.


```{r}
#| code-summary: "Calculate all combination distance"
#| echo: false
racf_list <- racf |>
  mutate(name = paste(location_address, suburb, " ")) |>
  select(name, longitude, latitude)

hosp_list <- hos_list |>
  left_join(patient |> select(hospitalname, long_hosp, lat_hosp),
            by = c("name" = "hospitalname")) |>
  rename(hospitalname = name) |> 
  distinct(hospitalname, long_hosp, lat_hosp) |> 
  na.omit()

combination_list <- expand_grid(racf_list, hosp_list)

combi_racf_sf <- combination_list |> 
  select(name, longitude, latitude) |>
  st_as_sf(coords = c("longitude", "latitude"), crs = st_crs(4326)) |> 
  rename(geometry_racf = geometry)

combi_hosp_sf <- combination_list |> 
  select(hospitalname, long_hosp, lat_hosp) |> 
  st_as_sf(coords = c("long_hosp", "lat_hosp"), crs = st_crs(4326)) |> 
  rename(geometry_hosp = geometry)

all_distance <- bind_cols(combi_racf_sf, combi_hosp_sf) |> 
  mutate(distance = st_distance(geometry_racf, geometry_hosp, by_element = TRUE),
         distance = as.double(distance))
```

```{r}
#| code-summary: "RACF close to hospital"
#| echo: false
close <- all_distance |>
  filter(distance == 0) |>
  distinct(name) |>
  pull(name) |>
  trimws()

patient_dist <- patient_dist |>
  mutate(check = ifelse(sceneaddress %in% toupper(close), "Co-located", "Non co-located"))
```

```{r}
#| code-summary: "Visualisation"
#| label: fig-distance-dis-close
#| echo: false
#| fig-cap: "Histogram of ambulance transfer distances for emergency and scheduled cases grouped by co-located RACF. The median is shown in a vertical blue line, while the first and third quartiles are shown in red. The median transfer distance for the co-located RACF is much higher than that of others."
patient_dist |>
  group_by(routine, check) |>
  mutate(median = median(distance + 1),
         q1 = quantile(distance + 1, prob = 0.25),
         q3 = quantile(distance + 1, prob = 0.75)) |>
  ggplot(aes(x = distance + 1)) +
  geom_histogram(bins = 45) +
  facet_wrap(~check + routine, scales = "free_y", ncol = 2) +
  geom_vline(aes(xintercept = median), color = "blue") +
  geom_vline(aes(xintercept = q1), color = "red") +
  geom_vline(aes(xintercept = q3), color = "red") +
  scale_x_log10() +
  labs(y = "Count", x = "Distance (log-scale)")
```

```{r}
#| code-summary: "Visualisation"
#| label: fig-racf-close-point
#| warning: false
#| echo: false
#| fig-cap: "The location of the RACF with the co-located RACF highlighted. The plot shows where all the RACFs are located in Victoria, with the one highlighted as the co-located facility. Most of the co-located facilities are in the regional area, with only a few in the Melbourne area."
simple_graph |>
  filter(category == "racf") |>
  ggraph(x = long, y = lat) +
  geom_sf(data = vic_map, color = "white") +
  geom_node_point(color = "red") +
  gghighlight(name %in% toupper(close))
```

The expectation of the transfer distance for the co-located RACF would be shorter than that of the other RACFs. However, as shown in @fig-distance-dis-close, the median transfer distance for the co-located RACF is higher. From @fig-racf-close-point, it can be seen that there are many more co-located RACFs in the regional area than in the Melbourne area, which might explain the bimodality observed in @fig-distance-dis-close. This bimodality is likely caused by the longer travel distances for regional RACFs compared to those in Melbourne.

To highlight this regional effect, a sample of RACFs will be visualised on a map. The sampling is used to reduce edge clustering while still representing the observational data, making it easier to observe patterns. Additionally, since there are many facilities inside the Melbourne area, hospitals in Melbourne will be grouped based on their emergency capabilities.

```{r}
#| code-summary: "Grouping melbourne hospital"
#| echo: false
#| message: false
hospital_melbourne <- hospital_location |>
  mutate(classification = ifelse(between(lat, -38.5, -37.5) &
                                 between(long, 144.5, 145.5),
                               "melbourne",
                               "regional")) |>
  filter(classification == "melbourne") |>
  pull(name)

hospital_emergency <- hos_list |>
  filter(emergency_capable == "YES") |>
  pull(name)

simulate_location <- tibble::tibble(name = c("MELBOURNE HOSPITAL EMERGENCY",
                                             "MELBOURNE HOSPITAL NON EMERGENCY"),
                                    long = c(144.9, 145.1),
                                    lat = c(-37.75, -37.75))

full_location_simulate <- bind_rows(full_location, simulate_location)

simple_group_graph <- transfers |>
  mutate(hospitalname = case_when(
                                  hospitalname %in% hospital_melbourne & 
                                    hospitalname %in% hospital_emergency 
                                  ~ "MELBOURNE HOSPITAL EMERGENCY",
                                  hospitalname %in% hospital_melbourne & 
                                    !(hospitalname %in% hospital_emergency) 
                                  ~ "MELBOURNE HOSPITAL NON EMERGENCY",
                                  .default = hospitalname
                                  )) |>
  rename(from = sceneaddress,
         to = hospitalname) |>
  group_by(from, to) |> 
  summarise(weight = sum(weight)) |> 
  as_tbl_graph() |>
  left_join(full_location_simulate, by = "name") |>
  mutate(category = case_when(
                              name %in% transfers$sceneaddress ~ "RACF",
                              name == "MELBOURNE HOSPITAL EMERGENCY" 
                              ~ "Melbourne Emergency",
                              name == "MELBOURNE HOSPITAL NON EMERGENCY" 
                              ~ "Melbourne Non Emergency",
                              .default = "Regional Hospital"
                              ),
         category = factor(category, 
                           levels = c("Melbourne Emergency", 
                                      "Melbourne Non Emergency", 
                                      "Regional Hospital", 
                                      "RACF"))
         )

set.seed(123)

sample_racf <- simple_group_graph |>
  activate(edges) |>
  mutate(from_name = .N()$name[from]) |>
  filter(from_name %in% toupper(close)) |>
  activate(nodes) |>
  filter(!node_is_isolated(),
         category == "RACF") |>
  sample_n(size = 5) |> 
  as_tibble() |>
  pull(name)
```

```{r}
#| code-summary: "Visualisation"
#| echo: false
#| warning: false
#| label: fig-group-close-net-spatial
#| fig-cap: "The sampled co-located RACF transfer network, where the Melbourne hospital is grouped. These facilities are placed according to their spatial coordinates (latitude and longitude), with a line representing the transfers and alpha representing the transfer volume. Most patients are sent to Melbourne hospitals."
simple_group_graph |>
  activate(edges) |>
  mutate(from_name = .N()$name[from]) |>
  filter(from_name %in% sample_racf) |>
  activate(nodes) |>
  filter(!node_is_isolated()) |>
  ggraph(x = long, y = lat) +
  geom_sf(data = vic_map, color = "white") +
  geom_edge_link(aes(edge_alpha = weight)) +
  geom_point(aes(x = x, y = y, color = category), position = position_dodge(0.1)) +
  scale_edge_alpha(guide = "none") +
  theme(legend.position = "bottom") +
  scale_color_brewer(palette = "Set1")
```

```{r}
#| code-summary: "Visualisation"
#| label: fig-group-close-net-free
#| echo: false
#| fig-cap: "The sample co-located RACF transfer network, where the Melbourne hospital is grouped on the non-spatial layout. The nodes are placed based on the stress layout, which helps spread out the nodes. The transfer of the patient from regional RACFs to Melbourne is clearer, and there are two clusters of transfers."
simple_group_graph |>
  activate(edges) |>
  mutate(from_name = .N()$name[from]) |>
  filter(from_name %in% sample_racf) |>
  activate(nodes) |>
  filter(!node_is_isolated()) |>
  ggraph(layout = "stress") +
  geom_edge_link(aes(edge_alpha = weight)) +
  geom_node_point(aes(color = category)) +
  theme(legend.position = "bottom") +
  scale_edge_alpha(guide = "none") +
  scale_color_brewer(palette = "Set1")
```

From @fig-group-close-net-spatial, it can be observed that the longer median travel distances shown in @fig-distance-dis-close are caused by the regional RACFs located in the regional area. Using spatial coordinates helps identify this pattern. However, this example also shows why mapping a network directly onto its spatial coordinates may not always be ideal. If the main focus of the plot is to highlight that most patients are transferred to Melbourne hospitals, this is not immediately clear in the spatial visualisation. Longer edges tend to attract more visual attention, and overlapping edges further obscure the transfer patterns.

In contrast, @fig-group-close-net-free shows the same network but using a graph-based layout instead. This representation makes the pattern of transfers to Melbourne hospital much clearer, and the two clusters are more distinctly separated. This comparison highlights the importance of choosing between spatial and graph-based layouts.

Extending this to interactive visualisation is not straightforward. In the case of spatial plots, node locations are given in the data, making it easier to add interactivity using functions such as `geom_point_interactive()`. For a graph layout plot, while nodes can be made interactive, the edges are more difficult. It is because the layout positions are calculated internally within `ggraph`, making it challenging to extract and reuse layout information for interactive edges using functions such as `geom_segment_interactive()`.

Following this, transfer reasons, such as dispatch type and diagnosis, will be explored. To make comparison and interpretation easier, the transfer distance will be grouped into four categories: zero-distance (co-located facilities), short-distance (between 0 and 10km), medium-distance (between 10km and 50km), and long-distance (above 50km).


```{r}
#| code-summary: "Grouping distance"
#| echo: false
patient_dist <- patient_dist |>
  mutate(distance_cat = case_when(
                          distance == 0 ~ "Zero",
                          between(distance, 1, 10000) ~ "Short-distance",
                          between(distance, 10000, 50000) ~ "Medium-distance",
                          distance > 50 ~ "Long-distance"
                                  ),
         distance_cat = factor(distance_cat,
                               levels = c("Zero", "Short-distance",
                                          "Medium-distance", "Long-distance")))
```

```{r}
#| code-summary: "Count the dispatch reason (RACF next to hospital)"
#| echo: false
text_close_dispatch <- patient_dist |> 
  st_drop_geometry() |> 
  filter(sceneaddress %in% toupper(close),
         routine == "Emergency") |> 
  count(distance_cat, dispatch) |> 
  group_by(distance_cat) |> 
  mutate(proportion = round(n/sum(n), 2)) |> 
  ungroup() |>
  rename(Dispatch = dispatch,
         Proportion = proportion)
```

```{r}
#| code-summary: "Dispatch reason"
#| label: tbl-dispatch
#| tbl-cap: "The dispatch reason proportion table for different distance categories. These tables display the top seven common dispatch reasons for each category. The common dispatch reason for zero and medium distances is urgent transfers, while medium to long distances is mental health."
#| tbl-subcap:
#|   - "Zero Distance"
#|   - "Short Distance"
#|   - "Medium Distance"
#|   - "Long Distance"
#| layout-ncol: 2
#| echo: false

text_close_dispatch |> 
  filter(distance_cat == "Zero") |> 
  arrange(-n) |> 
  select(Dispatch, Proportion) |> 
  head(7) |> 
  knitr::kable() 

text_close_dispatch |> 
  filter(distance_cat == "Short-distance") |> 
  arrange(-n) |> 
  select(Dispatch, Proportion) |> 
  head(7) |> 
  knitr::kable() 

text_close_dispatch |> 
  filter(distance_cat == "Medium-distance") |> 
  arrange(-n) |> 
  select(Dispatch, Proportion) |> 
  head(7) |> 
  knitr::kable() 

text_close_dispatch |> 
  filter(distance_cat == "Long-distance") |> 
  arrange(-n) |> 
  select(Dispatch, Proportion) |> 
  head(7) |> 
  knitr::kable() 
```

```{r}
#| code-summary: "Count the diagnosis reason (RACF next to hospital)"
#| echo: false
text_close_diagnosis <- patient_dist |> 
  st_drop_geometry() |> 
  filter(sceneaddress %in% toupper(close),
         routine == "Emergency") |> 
  count(distance_cat, diagnosis) |> 
  group_by(distance_cat) |> 
  mutate(proportion = round(n/sum(n), 2)) |> 
  ungroup() |>
  rename(Diagnosis = diagnosis,
         Proportion = proportion)
```

```{r}
#| code-summary: "Diagnosis reason"
#| label: tbl-diagnosis
#| tbl-cap: "The diagnosis reason proportion table for different distance categories. These tables display the top seven common diagnosis for each category. The common diagnosis for zero and medium distances is pain, while for medium to long distances is a psychiatric episode."
#| tbl-subcap:
#|   - "Zero Distance"
#|   - "Short Distance"
#|   - "Medium Distance"
#|   - "Long Distance"
#| layout-ncol: 2
#| echo: false

text_close_diagnosis |> 
  filter(distance_cat == "Zero") |> 
  arrange(-n) |> 
  select(Diagnosis, Proportion) |> 
  head(7) |> 
  knitr::kable() 

text_close_diagnosis |> 
  filter(distance_cat == "Short-distance") |> 
  arrange(-n) |> 
  select(Diagnosis, Proportion) |> 
  head(7) |> 
  knitr::kable() 

text_close_diagnosis |> 
  filter(distance_cat == "Medium-distance") |> 
  arrange(-n) |> 
  select(Diagnosis, Proportion) |> 
  head(7) |> 
  knitr::kable() 

text_close_diagnosis |> 
  filter(distance_cat == "Long-distance") |> 
  arrange(-n) |> 
  select(Diagnosis, Proportion) |> 
  head(7) |> 
  knitr::kable() 
```


### Next steps

  - Add road distance to the dataset as an additional distance comparison. Also, including an indicator for aerial transfers can be helpful since aerial transport typically takes less time to transfer the patient to the hospital.

  - Conduct a more in-depth analysis of the differences between emergency and scheduled transfers. The initial result (@fig-distance-dis) shows that there is not much difference between emergency and scheduled in terms of descriptive statistics and distribution. Further analysis would help to see if there are potential confounding variables.

  - Analyse the potential overuse of ambulance callouts. Ideally, the resources should not be overused in non-emergency situations, identifying potential overuse would allow for better resource allocation when needed (e.g., emergency state).

  - Examine the temporal patterns, such as peak demand for transfers. It would help inform policymakers about when additional ambulance resources are needed to prevent a system shortage.

  - Assess the impact of COVID-19 on transfer patterns. Understanding how COVID-19 affected the system would support future planning in the event of another pandemic or disruption.

  - Consider the implications for policymakers, such as the effects of a hospital shutdown. During the disease outbreaks, some hospitals may need to reserve their resources for specific cases, or the hospital is at full capacity. Understanding how this affects the transfer network would be useful for planning.

  - The work of Part B will help inform the development of the new data package, as well as applying the new package to the analysis. The analysis of the ambulance transfers will be turned into a publishable application paper.


# Project 2: Dynamics of Infectious Disease Modelling using a Generalised Ambulance Model

## Part A: Generalised Ambulance Model

This project focuses on understanding the impact of any changes in the ambulance transfer network on the spread of infectious diseases, particularly among older populations in residential aged care facilities. Ambulance transfer creates a way in which infections can be transmitted throughout facilities and hospitals [@gruber2013multidrug]. Variations in transfer volume, patterns, or constraints can alter the structure of the network and, in turn, influence outbreak dynamics.

There has been research using a spatio-temporal point process model to study ambulance demand rather than modelling the network structure. However, such work has primarily focused on ambulance deployment planning rather than transmission or transfer networks [@zhou2015spatio]. Since the main analysis is to examine the transfer patterns, models such as this do not adequately represent the connections between facilities, but instead focus on predicting demand over the area. Understanding the underlying contact network is therefore what is needed for studying the transfer network connections [@silk2017application]. There is a wide range of statistical network models available for studying, and these are potential models to look at.

  - **Exponential Random Graph Model (ERGM):** An ERGM is used to study the structure of network data by modelling the probability of observing a given network as a function of network structure and the characteristics of individuals (nodes) within the network [@robins2007introduction]. An advantage of ERGM is their ability to include individual traits (e.g., sex and age), which can be used to explain connection patterns and the likelihood of interacting with similar individuals. A limitation of the model is its lack of flexibility in specifying interaction terms, which is possible but not straightforward. ERGM can be fitted using the `ergm` R package [@ergm]. For dynamic networks, temporal extensions such as the temporal exponential random graph model can be fitted using the `btergm` package [@btergm].

  - **Latent Space Model:** Latent space models provide an alternative method to ERGMs for modelling relational data. These models basically work like generalised linear models for edge values, while controlling for the network dependence by placing nodes in k-dimensional space according to their social network distance [@hoff2002latent; @krivitsky2009representing]. The advantage of this model is its simpler implementation and fitting compared to ERGMs. However, interpretation of model coefficients can be challenging if the position of nodes in latent space covaries with values of nodal attributes [@cranmer2017navigating]. Latent space model can be fitted using the `latentnet` package [@krivitsky2008fitting].


## Part B: Dynamics of Infectious Disease Modelling

Antimicrobial resistance (AMR) poses a significant threat to our health. Several studies show that nursing homes or long-term care facilities are considered an important breeding ground for AMR [@tandan2022impact; @strausbaugh1996antimicrobial; @john1991antibiotic]. Therefore, RACFs act as important reservoirs for AMR, creating a concern for the broader healthcare system. Transfers of patients through ambulance between RACFs and hospitals create the pathways for these resistant organisms to spread around the system. Understanding patient movement patterns and characterising the spread is therefore essential for monitoring and controlling the transmission. 

Infectious disease dynamics describe how the disease is spread and evolves within the population over time. These dynamics depend on the contact between individuals or groups, movement between locations, and the timing of infection and recovery. Traditional compartmental models, such as susceptible-infectious-recovered (SIR) or susceptible-exposed-infectious-recovered (SEIR), are often used to represent the disease progression within and between groups. Through this modelling, policymakers can conduct scenario analyses on the ambulance transfer network. For example, these models can be used to assess how an outbreak evolves if a particular hospital becomes unavailable due to an outbreak and how this disruption affects disease transmission across the system.

Using a simulated network as input to an infectious disease transmission model allows disease spread to occur both within facilities (RACFs and hospitals) and between facilities through ambulance transfers. Similar approaches have been explored in the literature. However, rather than using the simulated network, it uses a point process model to predict demand and then uses this output as input to an infectious disease model [@amaral2023spatio].
  
  
# Timeline

## Progress Update

### Project 1A) Data cleaning and subsetting

  - I have explored multiple network analysis software, including `tidygraph`, `igraph` and `network` for comparison (@sec-storage). This helps identify the limitations of the current tools and what is needed for the new data object and its functionality.

  - I have applied the above software on [Caribou dataset](https://github.com/rfordatascience/tidytuesday/blob/main/data/2020/2020-06-23/readme.md), with the main focus on the temporal pattern. It helps see that the limitations of the `tidygraph` are its lack of support for temporal variables. It leads to considering an imputation strategy for temporal network data since there are many time gaps (@sec-storage) in the Caribou dataset that might affect the distance analysis.

### Project 1A) Data visualisation

  - I have experimented with crosstalk to create linked, side-by-side visualisations to combine a network and a simple descriptive plot. However, this will not be used going forward.

  - I constructed a supervisor-student relationship network as part of learning about network theory. This dataset is helpful since there are no strict spatial coordinates, thus, experiment with graph layout for placing the nodes.

  - I explored `ggiraph` for interactive network visualisation (@sec-visualisation). When drawing a large network, the amount of information shown on the plot can be limited, therefore, looking at alternatives such as interactivity to add more information to the visualisation.


### Project 1B) Exploratory data analysis

  - I did the preliminary analysis of the ambulance transfer efficiency (@sec-transferdist). This would help inform the development of the new data object and its functionality package.
  
### Project 2A) 

  - I try a statistical network model, such as `ergm` and `intergraph` for switching between `igraph` and `network` objects. It helps inform what the research gaps are in terms of statistical modelling with network data.


## Timeline

```{r}
#| label: fig-timeline
#| fig-cap: "A Gantt chart of my PhD project timeline. The sub-project name is shown alongside the expected timeline. Project 1 is planned to finish by the end of this year, and Project 2 is planned to finish by the end of next year."
#| fig-width: 12
#| fig-height: 5
#| echo: false
#| message: false
#| warning: false

prj1_data <- tribble(
  ~activity, ~start_date, ~end_date,
  "Review current tools", 1, 12,
  "Ambulance network exploration", 13, 21,
  "Developing network EDA infrastructure", 13, 15,
  "R package: new data object and functionality", 16, 24,
  "First paper: Review", 19, 19,
  "Second paper: Application: ", 25, 25,
  "Third paper: R tools", 30, 30) |> 
  mutate(wp = "Project 1")

prj2_data <- tribble(
  ~activity, ~start_date, ~end_date,
  "Generalise ambulance model", 22, 27,
  "Dynamics infectious disease modelling", 28, 36,
  "R package: Tidy tools for IDM", 22, 36,
  "Fourth paper: IDM", 37, 37) |> 
  mutate(wp = "Project 2")

conf_data <- tribble(
  ~wp, ~activity, ~start_date, ~end_date,
  "Conferences", "useR!", 31, 31,
  "Conferences", "ANZIAM", 38, 38
)

thesis_data <- tribble(
  ~wp, ~activity, ~start_date, ~end_date,
  "Thesis Submission", "Thesis writing", 37, 42
)

prj_data <- bind_rows(prj1_data, prj2_data, conf_data, thesis_data) |> 
  select(wp, activity, start_date, end_date)

ganttrify::ganttrify(
  project = prj_data,
  project_start_date = "2025-01",
  size_text_relative = 1.5,
  alpha_wp = 0,
  line_end_activity = "round"
) + 
  geom_vline(xintercept = as.numeric(as.Date(paste0(seq(2025, 2028), "-01-01"))),
             linetype = "dashed", color = "gray50") +
  scale_x_date(date_breaks = "3 months", 
             labels = function(x) {
               quarters <- paste0("Q", quarter(x))
               years <- format(x, "%Y")
               # Show year only for Q1
               ifelse(quarter(x) == 1, paste0(quarters, "\n", years), quarters)
             }) +
  theme(axis.title.x = element_blank())
```

## Potential papers output

- Paper 1: Methods for exploring multivariate spatio-temporal networks: A Review.

- Paper 2: Understanding the spatio-temporal network dynamics on aged care ambulance transfers in Victoria.

- Paper 3: A new tidy data structure for spatio-temporal multivariate network exploration and modelling.

- Paper 4: Modelling infectious disease dynamics using a generalised ambulance model.

 
## Planned conferences
 
The following is a list of conferences that I will be targeting to attend and showcase the work.

  - useR! Conference (July 2027): I am planning to present the work on my data object and functionality package at the conference. It will help me get some feedback as well as network with other researchers on R tools.
 
  - ANZIAM Conference (February 2028): I am planning to present the work on my Project 2, which is about the dynamics of infectious disease modelling, to receive feedback and networking with other researchers in the infectious disease discipline.
  

## Other activities

  - I have been co-hosting the Hacky Hour session with Janith over the last year. The Hacky Hour is a weekly session to share and foster knowledge on research software development. I plan to keep running the Hacky Hour session this year as well.
  
  - I was a Volunteer lead on the WOMBAT2025, helping with anything needed on the workshop day.
  
  - I taught a tutorial/workshop with Jayani and Janith on reproducible research in WOMBAT2025 and as part of the NUMBAT workshops. The tutorial introduces Quarto for creating reproducible reporting, academic documents and presentations.
  
  - Tutoring two units, ETC5512: Wild caught data and ETC5521: Diving deeply into data exploration.
  
  - Complete the two PhD compulsory units successfully, ETX6500: Statistical inference and ETX6510: Foundations of econometrics.
  
  
# Acknowledgements

The materials to generate this report are in the following [repository](https://github.com/KrisanatA/confirmation-report). I am committed to using GitHub version control and Quarto (with R) for reproducible research. It should be noted that the full data is private, which means that only those with access to the data can reproduce this report, at present. This research has been approved by the Alfred Health Ethics Committee, Local reference number 591/18.

I also acknowledge the use of ChatGPT (https://chat.openai.com/) and Grammarly to improve the text, grammar, and spelling.


---
nocite: |
  @gghighlight
---

