---
title: "Comfirmation Report"
author: "Krisanat Anukarnsakulchularp"
format: 
  html:
    toc: true
bibliography: report.bib
---

```{r}
#| message: false
#| echo: false
#| warning: false

# library
library(tidyverse)
library(ggplot2)
library(tidygraph)
library(ggraph)
library(sfnetworks)
library(sf)
library(ggiraph)
library(tsibble)
library(gghighlight)
library(ggthemes)

theme_set(
  theme_minimal()
)

options(scipen = 999)

pal_colorblind <- colorblind_pal()(8)[2:8]
```

```{r}
#| output: false
#| echo: false

# read data
address <- read_csv(here::here("data/ambulance/hospital_address.csv"))

hos_list <- read_csv(here::here("data/ambulance/Hospital_list.csv")) |>
  janitor::clean_names() |>
  rename(name = other_name) |>
  mutate(name = toupper(name))

patient <- read_csv(here::here("data/ambulance/patient_clean.csv")) |>
  select(!c(...1, ...2)) |>
  mutate(routine = ifelse(routine == 1, "Scheduled", "Emergency")) |>
  filter(iht != 1)

racf <- read_csv(here::here("data/ambulance/RACF_address.csv"))

transfers <- read_csv(here::here("data/ambulance/transfers_all.csv")) |>
  select(!...1)

vic_map <- read_sf(here::here("data/map/LGA_2025_AUST_GDA2020/LGA_2025_AUST_GDA2020.shp")) |>
  filter(STE_NAME21 == "Victoria")
```

```{r}
#| echo: false
racf_location <- transfers |>
  select(sceneaddress, long_racf, lat_racf) |>
  distinct() |>
  rename(long = long_racf,
         lat = lat_racf,
         name = sceneaddress) |> 
  mutate(type = "racf")

hospital_location <- transfers |>
  select(hospitalname, long_hosp, lat_hosp) |>
  distinct() |>
  rename(long = long_hosp,
         lat = lat_hosp,
         name = hospitalname) |> 
  mutate(type = "hospital")

full_location <- bind_rows(racf_location, hospital_location)

simple_graph <- transfers |>
  rename(from = sceneaddress,
         to = hospitalname) |>
  as_tbl_graph() |>
  left_join(full_location, by = "name") |>
  mutate(category = ifelse(name %in% transfers$sceneaddress, "racf", "hospital"))
```

# Background

Recently, exploring and analysing large network structure data has sparked more interest in the health field, particularly within emergency medical services (EMS) and ambulance systems. This increase is largely due to an advancement in technology, such as the Global Positioning System (GPS), mobile devices, and remote sensing, which have significantly contribute to the precision and volume of spatio-temporal data [@spatio-temporal]. This type of data captures information on both spatial and temporal context. The spatial component describes the location or spatial geometry, while the temporal component records time information such as a timestamp or time interval [@rao2012spatiotemporal].

The emergency medical services and ambulance systems have an important role in ensuring that patient transfers are performed effectively and in a timely manner. This is especially important for an older population, where the delay could lead to an increase in health risk [@harmsen2015influence]. Older individuals often require continuous support, including 24-hour care, assistance with daily tasks, and medical supervision. Thus, many reside in the residential aged care facilities (RACFs), which are specifically designed to provide this comprehensive care [@kearney2006nearby]. RACFs frequently rely on the ambulance services to facilitate the transfer of an individual to the hospital. It can be an acute emergency or planned/scheduled medical appointments. The increase in demand for these transfers is driven by population ageing [@harris2018estimating]. It put incredible pressure on the ambulance resource and highlights the need for efficient planning and utilisation of the service.

To gain insight into the transfer patterns, the data exploration, along with network representations linking RACFs and hospitals, provides a powerful framework. Network-based representations of the data are naturally perceived as relational, and people often associate the flow and connections with it. However, most network research tends to be conducted homogeneously, focusing primarily on the network topological properties while overlooking other important pieces of information, for example, the association between variables. While network representation is a powerful tool, especially for the transfers data, overemphasising network typology can lead to the neglect of the fundamental principles of data exploration. Which encourages a free investigation of the data to uncover patterns and unexpected results. Simple informative analyses, such as examining variable distribution, temporal trends, or even bivariate relationships, can reveal a lot of insights into transfer frequency, efficiency, and demand that are often masked by the network structure. Integrating data exploration with network-based approaches, therefore, allows for a better understanding of the RACF and hospital transfer.

Studying how infectious diseases spread throughout the network (transfer between RACFs and hospitals) is important because the older population tend to face a higher risk of mortality during the outbreaks [@parohan2020risk]. These patient transfers between facilities create ways for the disease to be transmitted across the systems, leading to rapid spread. Traditional compartmental infectious disease models assuming homogeneous or static structure do not adequately capture networks that change over time. In reality, ambulance transfers are highly dynamic, where these connections between facilities can change in response to the demand, constraints, and even outbreak conditions. Understanding these transmission dynamics is therefore crucial for devising effective policies for stopping the spread of the disease. Combining a data exploration framework, which helps understand how the transfer network changes over time, with dynamic modelling that assesses how these changes affect the disease spread, is critical for identifying high-risk facilities, transfer connections, and periods.


# Project 1: Developing Infrastructure for Exploratory Analysis of Multivariate Spatio-temporal Network

## Part A: A Multivariate Spatio-Temporal Network Data Exploration Framewok

As multivariate spatio-temporal network data become more accessible and complex, understanding their structure and dynamics is key to effective decision-making. A major challenge with the analysis of large multivariate networks is the amount of information they contain, most of which is overlooked. By integrating exploratory data analysis (EDA) with network-based representations, the framework aims to support an examination of associations between variables, temporal changes, and structural differences within the network. Throughout this framework, a seamless integration of the following key processes is needed: data storage, cleaning, subsetting, visualisation, and visual inference. The following section, therefore, reviews existing tools that support these processes and discusses their limitations.


### Data Storage and Cleaning

Data cleaning is the first stage of a reliable analysis. Spatio-temporal data usually need to be checked for inconsistency of the temporal records, duplicated records, and spatial inaccuracies. Now, adding the network structure on top of that, such as nodes, edges, and their attributes, requires the network topology to be kept throughout the process. Typically, this stage involves tools such as `dplyr` [@dplyr] for manipulating the data, `tsibble` [@tsibble] for validating the temporal inconsistency, `sf` [@sf] for checking the coordinate inaccuracies, and `igraph`/`network` [@igraph, @network] for keeping the network structure.

The `tidygraph` [@tidygraph] package provides a tidy API for graph and network manipulation, where network data are thought of as two tidy tables, one for node and one for edge data. In tidy data [@tidy-data], each variable has its own column, each observation has its own row, and each value has its own cell. These tables are then stored together within a `tbl_graph` object, which preserves the underlying network topology while allowing standard `dplyr` verbs to be applied. The interaction between node and edge tables is done through the use of a special function, `activate()`, which allows the user to switch between the two tables and apply `dplyr` operations such as `mutate()`, `group_by()`, and join operations.

There are two main functions for creating `tbl_graph` object, `as_tbl_graph()` and `tbl_graph()`. The first function `as_tbl_graph()` takes in a different class of objects, such as `data.frame`, `igraph`, and `network`, then turns it into a `tbl_graph` object. While `tbl_graph()` takes in two `data.frame` objects, one for node and one for edge.

```{r}
#| echo: false
racf_nodes <- transfers |> 
  distinct(sceneaddress, long_racf, lat_racf) |>
  rename(name = sceneaddress,
         longitude = long_racf,
         latitude = lat_racf) |> 
  mutate(type = "racf")

hospital_nodes <- transfers |>
  distinct(hospitalname, long_hosp, lat_hosp) |>
  rename(name = hospitalname,
         longitude = long_hosp,
         latitude = lat_hosp) |>
  mutate(type = "hospital")

nodes <- bind_rows(racf_nodes, hospital_nodes)

edges <- transfers |> 
  rename(from = sceneaddress,
         to = hospitalname)
```

```{r}
as_tbl_graph(edges)

tbl_graph(nodes, edges)
```

The difference between these two methods is that for the `as_tbl_graph()` function, it only needs the edges dataset, which means that all the multivariate information will only be on edge data and in the node data, it will only have the name (location). For the `tbl_graph()` function, the node variable can be explicitly stated, which can come in handy when there are attributes on the node dataset.

```{r}
graph <- tbl_graph(nodes, edges)

graph |>
  activate(nodes) |>
  mutate(degree = centrality_degree(weights = weight))

graph |>
  activate(edges) |>
  mutate(centrality = centrality_edge_betweenness(weights = weight)) 
```

For spatial networks, the `sfnetworks` package [@sfnetworks] extends `tidygraph` by allowing spatial geometries to be incorporated directly within the `tbl_graph` object. It is useful for dealing with complex geometry where edges are not straight-line connections, such as road or transport networks. The package also allows for the standard spatial operation within the `sf` package to be performed within the network context. For the temporal data structure provided by `tsibble` are not directly compatible with `tidygraph` objects. As a result, validating temporal consistency requires converting data back to a `tsibble` object or performing a temporal check prior to the creation of `tbl_graph`.

<!-- However, the temporal data structure provided by `tsibble` is not directly compatible with `tidygraph` objects. As a result, validating temporal consistency requires converting data back to a `tsibble` object or performing a temporal check prior to the creation of `tbl_graph`. It introduces an important limitation, where common operations of filling missing observations are done outside the network context and therefore do not preserve the network topology. For example, if a node is missing in January 2020, how should the edges associated with that node be imputed? A sensible solution is to assume no edges exist during that period, which is reasonable in some cases but not in all cases. It highlights a key challenge in cleaning spatio-temporal network data, where temporal consistency and network structure should be considered jointly. The challenges require careful methodological decisions to ensure that both temporal attributes and the relational structure of the network remain coherent throughout the cleaning process. -->


### Data subsetting {#sec-datasubsetting}

Data subsetting is used to extract a subset of spatio-temporal network data based on spatial, temporal, and multivariate variables. This includes grouping data by time periods or regions, as well as filtering based on variable values and network characteristics (e.g., in-degree). In a network context, filtering operations need to account for topological dependencies between nodes and edges. When nodes are removed based on a condition, all edges incident to those nodes are also deleted (@fig-node-filter). In contrast, when edges are removed, the nodes connected to those edges are preserved, since nodes can exist independently from an edge (@fig-edge-filter). The `tidygraph` supports these subsetting operations through the use of `dplyr` functions such as `filter()` and `select()`, which are applied separately on nodes and edges while maintaining the condition of the underlying network. Similarly to the data manipulation, users will need to switch between the node and edge tables to subset based on their attributes.

```{r}
#| echo: false
nodes_example <- tibble(name = c(1, 2, 3, 4, 5),
                        x = c(1, 1.5, 2, 2, 3),
                        y = c(2, 1, 2, 3, 1))

edges_example <- tibble(from = c(1, 1, 2, 3, 3),
                        to = c(2, 3, 3, 4, 5))

graph_example <- tbl_graph(nodes = nodes_example, edges = edges_example, directed = FALSE)
```

```{r}
#| label: fig-node-filter
#| layout-ncol: 3
#| echo: false
#| fig-cap: "Node filtering"
#| fig-subcap:
#|  - "Full network"
#|  - "Node to be remove"
#|  - "Filtered network"

graph_example |> 
  ggraph(x = x, y = y) + 
  geom_edge_link() +
  geom_node_point(size = 10, color = "blue")

graph_example |> 
  mutate(check = as.factor(ifelse(name == "5", 1, 0))) |> 
  ggraph(x = x, y = y) +
  geom_edge_link() +
  geom_node_point(aes(color = check), size = 10) +
  scale_color_manual(values = c("blue", "red")) +
  theme(legend.position = "none")
  
graph_example |> 
  mutate(check = as.factor(ifelse(name == "5", 1, 0))) |> 
  activate(edges) |> 
  mutate(check = as.factor(ifelse(to == "5", 1, 0))) |> 
  ggraph(x = x, y = y) +
  geom_edge_link(aes(color = check)) +
  geom_node_point(aes(color = check), size = 10) +
  scale_color_manual(values = c("blue", "white")) +
  scale_edge_color_manual(values = c("black", "white")) +
  theme(legend.position = "none")
```

```{r}
#| label: fig-edge-filter
#| layout-ncol: 3
#| echo: false
#| fig-cap: "Edge filtering"
#| fig-subcap:
#|  - "Full network"
#|  - "Edges to be remove"
#|  - "Filtered network"

graph_example |> 
  ggraph(x = x, y = y) + 
  geom_edge_link(color = "blue") +
  geom_node_point(size = 10)

graph_example |> 
  activate(edges) |> 
  mutate(check = as.factor(ifelse(to %in% c("4", "5"), 1, 0))) |> 
  ggraph(x = x, y = y) +
  geom_edge_link(aes(color = check)) +
  geom_node_point(size = 10) +
  scale_color_manual(values = c("blue", "red")) +
  scale_edge_color_manual(values = c("blue", "red")) +
  theme(legend.position = "none")

graph_example |> 
  activate(edges) |> 
  mutate(check = as.factor(ifelse(to %in% c("4", "5"), 1, 0))) |> 
  filter(check != 1) |> 
  ggraph(x = x, y = y) +
  geom_edge_link(color = "blue") +
  geom_node_point(size = 10) +
  theme(legend.position = "none")
```

```{r}
graph |>
  activate(nodes) |> 
  filter(type == "racf")

graph |> 
  activate(edges) |> 
  select(-c(long_hosp:lat_racf)) |> 
  filter(weight > 100)
```

### Network Sampling

Another important aspect of subsetting is understanding how sampling methods perform on network data. Read-world datasets are often not evenly distributed across multiple dimensions such as time, space, or variable groups. Some strata may contain more observations than others, and analysing these can directly impact the interpretation, as the larger group of strata may dominate the patterns seen. Sampling provides a way to pick the data while keeping it representative of the population. Stratified sampling, in particular, helps with an imbalance case by dividing the data into subgroups and sampling within each group, ensuring that all groups are represented in the sampled data.

In the network context, sampling methods are generally categorised into three main classes [@chuong2025network]:

  - **Node-based sampling** selects a subset of nodes from the network and retains edges that are incident to the sampled nodes. This method is efficient and is usually implemented in large-scale studies [@ben2022sampling]. It often fails to capture important global structural properties such as connectivity and clustering.

  - **Edge-based sampling** samples a subset of edges directly and includes the nodes incident to those edges. This method is better at preserving structural patterns [@jiao2024sampling]. However, it may introduce bias towards selecting nodes with higher degrees, resulting in biased sampled data.
  
  - **Exploration-based sampling** constructs samples by traversing the network, for example, using random walks or snowball sampling [@goodman1961snowball]. These methods are good at preserving local connectivity and community structure, but are sensitive to the initial seed choice. A densely connected or highly accessible section of the network may get overrepresented. A detailed discussion of exploration-based sampling is beyond the current scope of this work.

The `tidgraph` package provides a method for sampling the data for a `tbl_graph` object through a `sample_n()` function. However, `sample_n()` has been superseded by `slice_sample()`, which is the current recommended approach for random sampling. Although the `sample_n()` function is not expected to be deprecated in the near future, it is currently limited to only critical bug fixes. A further limitation of the `tbl_graph` object is on stratified sampling, which is not directly supported, requiring converting the `tbl_graph` object back into a `tibble` [@tibble], performing stratified sampling on the node or edge table, and then filtering the original network based on the sampled nodes or edges. 

```{r}
#| echo: false
full_edges <- patient |> 
  rename(from = sceneaddress,
         to = hospitalname)

full_graph <- tbl_graph(nodes = full_location, edges = full_edges)
```

```{r}
#| message: false
set.seed(1)

full_graph |> 
  activate(nodes) |> 
  sample_n(size = 20)

full_graph |> 
  activate(edges) |> 
  sample_n(size = 20)

full_graph |> 
  activate(edges) |> 
  sample_n(size = 20) |> 
  activate(nodes) |> 
  filter(!node_is_isolated())

node_kept <- full_graph |> 
  activate(nodes) |> 
  as_tibble() |> 
  group_by(type) |> 
  sample_n(size = 10) |> 
  pull(name)

graph |> 
  filter(name %in% node_kept)

edges_kept <- full_graph |> 
  activate(edges) |> 
  as_tibble() |> 
  group_by(daytype) |> 
  sample_n(size = 10) |> 
  pull(single_id)

full_graph |> 
  activate(edges) |> 
  filter(single_id %in% edges_kept) |> 
  activate(nodes) |> 
  filter(!node_is_isolated())
```

As discussed in @sec-datasubsetting, nodes in a network can exist independently without incident edges. Thus, the edge-based sampling does not automatically remove nodes that become isolated after sampling. To remove these nodes, they must be explicitly removed by filtering the node table using the `node_is_isolated()` function.


### Data visualisation

Data visualisation helps reveal patterns, anomalies and relationships that may not be apparent from numerical summaries alone. Network data is often viewed as connections or flows between nodes/locations, and network-based visualisation allows for easier communication to a broader audience. For a simple network without spatial coordinates, placing nodes and edges in a visualisation requires the use of a graph layout algorithm, such as the Kamada-Kawai layout [@kk]. Depending on the chosen algorithm, the positions of nodes and edges can be different even on the same network dataset. With spatial information, visualising these becomes more straightforward, as longitude and latitude can be used to specify the actual location of the nodes, with edges represented as lines connecting these locations.

```{r}
#| label: fig-static-network
#| fig-cap: "An ambulance transfers network in Victoria between residential aged care facilities and hospitals."
#| code-summary: "Visualisation"

simple_graph |> 
  ggraph(x = long, y = lat) +
  geom_sf(data = vic_map, color = "white") +
  geom_edge_link(alpha = 0.1) +
  geom_node_point(aes(color = category))
```

Visualising high-dimensional network data can be challenging, especially through a static visualisation alone. The current tool for network visualisation in R is the `ggraph` package [@ggraph], which extends the `ggplot2` package [@ggplot2] to support relational data structures such as networks, graphs, and trees. The `ggraph` package is effective at visualising static networks, offering a range of layout algorithms for placing the node locations while keeping the same familiar `ggplot2` syntax. The support for interactive network visualisation with `ggraph` is currently limited. The reason static network visualisation is hard is that the amount of information that can be mapped to the visualisation is limited within a single figure. As shown in @fig-static-network, just a simple network representation can already become cluttered quickly. Answering detailed questions such as the number of transfers between a specific RACF and Hospital, or the name of a particular RACF, is difficult using static visualisation alone. Interactive visualisation help with these limitation by layering additional information onto the visualisation, allowing for further exploration.

```{r}
#| label: fig-interact-node
#| fig-cap: "An ambulance transfers network in Victoria between residential aged care facilities and hospitals with an interactive node."
#| code-summary: "Visualisation"
interactive_vis_node <- simple_graph |> 
  mutate(name = str_remove(name, "'")) |> 
  ggraph(x = long, y = lat) +
  geom_sf(data = vic_map, color = "white") +
  geom_edge_link(alpha = 0.1) +
  geom_point_interactive(aes(x = x, 
                             y = y,
                             color = category,
                             tooltip = name,
                             data_id = name))

girafe(ggobj = interactive_vis_node,
       options = list(
         opts_hover(css = "fill:lightblue;stroke:grey;stroke-width:0.5px"),
         opts_zoom(min = 0.5, max = 3)
       ))
```

```{r}
#| label: fig-interact-edge
#| fig-cap: "An ambulance transfers network in Victoria between residential aged care facilities and hospitals with an interactive edge."
#| code-summary: "Visualisation"

interactive_vis_edge <- simple_graph |> 
  ggraph(x = long, y = lat) +
  geom_sf(data = vic_map, color = "white") +
  geom_node_point(aes(color = category)) +
  geom_segment_interactive(
    data = simple_graph |> activate(edges) |> as_tibble() |> mutate(id = row_number()),
    alpha = 0.2,
    aes(x = long_racf,
        y = lat_racf,
        xend = long_hosp,
        yend = lat_hosp,
        tooltip = weight,
        data_id = id))
  

girafe(ggobj = interactive_vis_edge,
       options = list(
         opts_hover(css = "fill:lightblue;stroke:grey;stroke-width:0.5px"),
         opts_zoom(min = 0.5, max = 3)
       ))
```

The `ggiraph` package [@ggiraph] provides an interactive element to the visualisation through the `ggplot2` extension. Creating interactive network visualisations, therefore, typically requires combining `ggraph` for layout construction with `ggiraph` for interactivity. Getting this to work together requires an insight into how `ggraph` works, which is not a seamless implementation. For example, `ggraph` provides `geom_node_*` and `geom_edge_*` functions for nodes and edges geometry, respectively, but these do not natively support interactivity. To make nodes interactive, `geom_point_interactive()` need to be use instead of `geom_node_point()`. Making edges interactive is more complex as it requires the use of `geom_segment_interactive()` and mapping the start and end coordinates (`x`, `y`, `xend`, `yend`) for each edge. By that point, if both node and edge need interactivity, then `ggraph` is not needed, and instead the node and edge can be treated as a different dataset and implement geom_point and geom_segment for drawing the node and edge.


### Visual Inference


## Part B: Exploratory Analysis of Ambulance Demand and Efficiency

The efficiency of the ambulance transfer is critical in both scheduled and emergency transfer cases to minimise the resources used and affect the patient outcomes. In scheduled transfers, the longer the transfer, the fewer ambulances are available in the system, which potentially limits the number of ambulances available during the peak demand or emergency state. In emergency transfers, it directly influences the outcomes of the patient, especially for time-sensitive conditions such as trauma, cardiac emergencies, and stroke. Analysing ambulance transfer efficiency is therefore crucial for improving the quality of emergency care, ensuring an adequate number of available ambulances, and strengthening the system. In addition, predicting ambulance demand is also important as it allows the services to plan accordingly in different scenarios (e.g. peak demand).

The ambulance transfer data was provided by Alfred Health. The dataset included the following aspects: spatial, temporal, and multivariate information on each transfer. The spatial covers the location of the aged care facilities and the hospital (destination) in latitude and longitude. While the temporal provides the date of the transfers, which cover the period between January 2018 and May 2022. For multivariate information, it covers hospitals, aged care facilities, and patient-level details.


### Efficiency

The efficiency of the ambulance transfer is critical in both the case of scheduled and emergency transfer to minimise the use of resources. In the schedules service, the longer the transfer, the fewer ambulances are avaiable in the system, which poentially limits the number of ambulances available during an emergency state. For the emergency case, it directly influences the outcomes of the patient, espcially for time sensitive consitions such as trauma, cardiac emergencies, and stroke. The analysis of the ambulance transfer is therefore crucial for improving the quality of emergency care, ensuring an adequate number of available ambulances, and strengthening the system.

Measuring efficiency can be done in many ways; one of the proxies that can be used for estimating these is the distance from the aged care facilities to hospital. The haversine distance is one that takes into account the curvature of the Earth. However, given the area covered by the dataset, the Euclidean distance will be used instead. It calculates the shortest distance between two points using the latitude and longitude. This measure should give a reasonable estimate for less computing compared to the actual road distance. Note that the limitation is that it ignores the actual street network distance, which is not a straight line, and therefore, the distance between the RACF and the hospital will generally be longer.

```{r}
#| code-summary: "Calculate distance"
#| echo: false
racf_sf <- patient |> 
  select(-c(hospitalname, long_hosp, lat_hosp)) |> 
  st_as_sf(coords = c("long_racf", "lat_racf"), crs = st_crs(4326)) |> 
  rename(geometry_racf = geometry)

hosp_sf <- patient |> 
  select(hospitalname, long_hosp, lat_hosp) |> 
  st_as_sf(coords = c("long_hosp", "lat_hosp"), crs = st_crs(4326)) |> 
  rename(geometry_hosp = geometry)

patient_dist <- bind_cols(racf_sf, hosp_sf) |> 
  mutate(distance = st_distance(geometry_racf, geometry_hosp, by_element = TRUE),
         distance = as.double(distance))
```

```{r}
#| code-summary: "Visualisation"
#| label: fig-distance-dis
#| echo: false
patient_dist |>
  ggplot(aes(x = distance + 1)) +
  geom_histogram(bins = 45) +
  facet_wrap(~routine, scales = "free_y", ncol = 1) +
  scale_x_log10() +
  labs(y = "Count", x = "Distance (log-scale)")
```

```{r}
#| echo: false

dist_dis <- patient_dist |>
  filter(distance != 0) |>
  pull(distance)
```

From @fig-distance-dis, there seems to be zero distance transfer in the data, which might suggest either a data entry error or that the aged care facilities and hospital are next to each other. In the latter case, this might suggest that it may not need the ambulance to transfer the patient. After filtering the distance data to zero and manually going through them, it can be seen that the location of the aged care facility and hospital is, in fact, the same location. 

In an emergency case, it is important that the transfer is done quickly. It means that most of the time, the RACF that is right next to the hospital should not have a patient transferred to another hospital. One thing that will need to be considered is that the hospital, which is right next to the RACF, might not be able to handle the emergency case. In this case, the patient should be transferred to another emergency-capable hospital. This information can be verified through the hospital data, which has a column indicating whether the hospital has an emergency department or not.

Based on this information, the efficiency can be improved through fewer transfers to the other hospital that is further away, especially the RACF, whose location is right next to the hospital. To check this, the distance is calculated between the RACF and hospital for all the possible combinations to see which RACF is next to which hospital.

```{r}
#| code-summary: "Calculate all combination distance"
#| echo: false
racf_list <- racf |>
  mutate(name = paste(location_address, suburb, " ")) |>
  select(name, longitude, latitude)

hosp_list <- hos_list |>
  left_join(patient |> select(hospitalname, long_hosp, lat_hosp),
            by = c("name" = "hospitalname")) |>
  rename(hospitalname = name) |> 
  distinct(hospitalname, long_hosp, lat_hosp) |> 
  na.omit()

combination_list <- expand_grid(racf_list, hosp_list)

combi_racf_sf <- combination_list |> 
  select(name, longitude, latitude) |>
  st_as_sf(coords = c("longitude", "latitude"), crs = st_crs(4326)) |> 
  rename(geometry_racf = geometry)

combi_hosp_sf <- combination_list |> 
  select(hospitalname, long_hosp, lat_hosp) |> 
  st_as_sf(coords = c("long_hosp", "lat_hosp"), crs = st_crs(4326)) |> 
  rename(geometry_hosp = geometry)

all_distance <- bind_cols(combi_racf_sf, combi_hosp_sf) |> 
  mutate(distance = st_distance(geometry_racf, geometry_hosp, by_element = TRUE),
         distance = as.double(distance))
```

```{r}
#| code-summary: "RACF close to hospital"
#| echo: false
close <- all_distance |>
  filter(distance == 0) |>
  distinct(name) |>
  pull(name) |>
  trimws()
```

```{r}
#| code-summary: "Dispatch reason"
#| echo: false
patient_dist <- patient_dist |>
  mutate(check = ifelse(sceneaddress %in% toupper(close), "Close", "Far"))

patient_dist |>
  filter(check == "Close") |>
  count(dispatch, sort = TRUE) |>
  st_drop_geometry() |>
  filter(n > quantile(n, probs = 0.95)) |>
  knitr::kable(caption = "RACF that is close to hospital")

patient_dist |>
  filter(check == "Far") |>
  count(dispatch, sort = TRUE) |>
  st_drop_geometry() |>
  filter(n > quantile(n, probs = 0.95)) |>
  knitr::kable(caption = "RACF that is far from hospital")
```

```{r}
#| code-summary: "Visualisation"
#| label: fig-distance-dis-close
#| echo: false
patient_dist |>
  ggplot(aes(x = distance + 1)) +
  geom_histogram(bins = 45) +
  facet_wrap(~check + routine, scales = "free_y", ncol = 2) +
  scale_x_log10() +
  labs(y = "Count", x = "Distance (log-scale)")
```

The expectation of the transfer distance for the RACF that is close to the hospital would be, on average, less than that of the other case. However, from @fig-distance-dis-close, it can be seen that, on average, the transfer distance for the RACF that is next to the hospital is higher. It actually raises more questions about why this is the case.

```{r}
#| code-summary: "Visualisation"
#| label: fig-racf-close-net
#| echo: false
simple_graph |>
  activate(edges) |>
  mutate(from_name = .N()$name[from]) |>
  filter(from_name %in% toupper(close)) |>
  activate(nodes) |>
  filter(!node_is_isolated()) |>
  ggraph(x = long, y = lat) +
  geom_sf(data = vic_map, color = "white") +
  geom_edge_link(alpha = 0.1) +
  geom_node_point(aes(color = category)) +
  scale_color_manual(values = c("grey", "blue"))
```

```{r}
#| code-summary: "Visualisation"
#| label: fig-racf-close-point
#| warning: false
#| echo: false
simple_graph |>
  filter(category == "racf") |>
  ggraph(x = long, y = lat) +
  geom_sf(data = vic_map, color = "white") +
  geom_node_point(color = "red") +
  gghighlight(name %in% toupper(close))
```

From @fig-racf-close-net, it can be observed that a lot of patients got transferred from the regional to the Melbourne area. Though visualising this can be hard on the map because the Melbourne area is smaller than the regional area, therefore, a lot of points inside the Melbourne area will get squished together, which makes it hard to visualise. One of the solutions is to group the hospitals within Melbourne together by their emergency capabilities.

```{r}
#| code-summary: "Grouping melbourne hospital"
#| echo: false
hospital_melbourne <- hospital_location |>
  mutate(classification = ifelse(between(lat, -38.5, -37.5) &
                                 between(long, 144.5, 145.5),
                               "melbourne",
                               "regional")) |>
  filter(classification == "melbourne") |>
  pull(name)

hospital_emergency <- hos_list |>
  filter(emergency_capable == "YES") |>
  pull(name)

simulate_location <- tibble::tibble(name = c("MELBOURNE HOSPITAL EMERGENCY",
                                             "MELBOURNE HOSPITAL NON EMERGENCY"),
                                    long = c(144.75, 145.25),
                                    lat = c(-38, -38))

full_location <- bind_rows(full_location, simulate_location)

simple_group_graph <- transfers |>
  mutate(hospitalname = case_when(
                                  hospitalname %in% hospital_melbourne & 
                                    hospitalname %in% hospital_emergency 
                                  ~ "MELBOURNE HOSPITAL EMERGENCY",
                                  hospitalname %in% hospital_melbourne & 
                                    !(hospitalname %in% hospital_emergency) 
                                  ~ "MELBOURNE HOSPITAL NON EMERGENCY",
                                  .default = hospitalname
                                  )) |>
  rename(from = sceneaddress,
         to = hospitalname) |>
  as_tbl_graph() |>
  left_join(full_location, by = "name") |>
  mutate(category = case_when(
                              name %in% transfers$sceneaddress ~ "RACF",
                              name == "MELBOURNE HOSPITAL EMERGENCY" 
                              ~ "Melbourne Emergency",
                              name == "MELBOURNE HOSPITAL NON EMERGENCY" 
                              ~ "Melbourne Non Emergency",
                              .default = "Regional Hospital"
                              ),
         category = factor(category, 
                           levels = c("Melbourne Emergency", 
                                      "Melbourne Non Emergency", 
                                      "Regional Hospital", 
                                      "RACF"))
         )
```

```{r}
#| code-summary: "Visualisation"
#| echo: false
#| label: fig-group-close-net-spatial
simple_group_graph |>
  activate(edges) |>
  mutate(from_name = .N()$name[from]) |>
  filter(from_name %in% toupper(close)) |>
  activate(nodes) |>
  filter(!node_is_isolated()) |>
  ggraph(x = long, y = lat) +
  geom_sf(data = vic_map, color = "white") +
  geom_edge_link(alpha = 0.1) +
  geom_node_point(aes(color = category)) +
  theme(legend.position = "bottom") +
  scale_color_manual(values = pal_colorblind[1:4])
```

```{r}
#| code-summary: "Visualisation"
#| label: fig-group-close-net-free
#| echo: false
simple_group_graph |>
  activate(edges) |>
  mutate(from_name = .N()$name[from]) |>
  filter(from_name %in% toupper(close)) |>
  activate(nodes) |>
  filter(!node_is_isolated()) |>
  ggraph(layout = "stress") +
  geom_edge_link(alpha = 0.3) +
  geom_node_point(aes(color = category)) +
  theme(legend.position = "bottom") +
  scale_color_manual(values = pal_colorblind[1:4])
```

The question is why these RACFs, which are right next to the hospital, have to transfer the patient to the hospital that is further away. From the summarising process, there is a repeated distance which might suggest that there is a common hospital that RACF likes to use, or there might be a common symptom that this is the closest hospital that can treat it.


#### Transfer Distance

To further analyse the common reason for the patient transfer (RACF next to Hospital), the transfer distance will be grouped into the following;

- Zero distance (RACF and Hospital that is co-located)

- Between 0 and 10km (Short-distance)

- Between 10km and 50km (Medium-distance)

- Above 50km (Long-distance)


##### Dispatch Reason

```{r}
#| code-summary: "Grouping distance"
#| echo: false
patient_dist <- patient_dist |>
  mutate(distance_cat = case_when(
                          distance == 0 ~ "Zero",
                          between(distance, 1, 10000) ~ "Short-distance",
                          between(distance, 10000, 50000) ~ "Medium-distance",
                          distance > 50 ~ "Long-distance"
                                  ),
         distance_cat = factor(distance_cat,
                               levels = c("Zero", "Short-distance",
                                          "Medium-distance", "Long-distance")))
```

```{r}
#| code-summary: "Count the dispatch reason (RACF next to hospital)"
#| echo: false
text_close_dispatch <- patient_dist |> 
  st_drop_geometry() |> 
  filter(sceneaddress %in% toupper(close),
         routine == "Emergency") |> 
  count(distance_cat, dispatch)
```

```{r}
#| code-summary: "Dispatch reason (zero)"
#| echo: false

text_close_dispatch |> 
  filter(distance_cat == "Zero") |> 
  arrange(-n) |> 
  select(dispatch, n) |> 
  filter(n > quantile(n, probs = 0.8)) |> 
  knitr::kable(caption ="Zero Distance") 
```

```{r}
#| code-summary: "Dispatch reason (short)"
#| echo: false

text_close_dispatch |> 
  filter(distance_cat == "Short-distance") |> 
  arrange(-n) |> 
  select(dispatch, n) |> 
  filter(n > quantile(n, probs = 0.8)) |> 
  knitr::kable(caption ="Short Distance") 
```

```{r}
#| code-summary: "Dispatch reason (medium)"
#| echo: false

text_close_dispatch |> 
  filter(distance_cat == "Medium-distance") |> 
  arrange(-n) |> 
  select(dispatch, n) |> 
  filter(n > quantile(n, probs = 0.8)) |> 
  knitr::kable(caption ="Medium Distance") 
```

```{r}
#| code-summary: "Dispatch reason (long)"
#| echo: false

text_close_dispatch |> 
  filter(distance_cat == "Long-distance") |> 
  arrange(-n) |> 
  select(dispatch, n) |> 
  filter(n > quantile(n, probs = 0.8)) |> 
  knitr::kable(caption ="Long Distance") 
```



##### Diagnosis Reason

```{r}
#| code-summary: "Count the diagnosis reason (RACF next to hospital)"
#| echo: false
text_close_diagnosis <- patient_dist |> 
  st_drop_geometry() |> 
  filter(sceneaddress %in% toupper(close),
         routine == "Emergency") |> 
  count(distance_cat, diagnosis)
```

```{r}
#| code-summary: "Diagnosis reason (zero)"
#| echo: false

text_close_diagnosis |> 
  filter(distance_cat == "Zero") |> 
  arrange(-n) |> 
  select(diagnosis, n) |> 
  filter(n > quantile(n, probs = 0.8)) |> 
  knitr::kable(caption ="Zero Distance") 
```

```{r}
#| code-summary: "Diagnosis reason (short)"
#| echo: false

text_close_diagnosis |> 
  filter(distance_cat == "Short-distance") |> 
  arrange(-n) |> 
  select(diagnosis, n) |> 
  filter(n > quantile(n, probs = 0.8)) |> 
  knitr::kable(caption ="Short Distance") 
```

```{r}
#| code-summary: "Diagnosis reason (medium)"
#| echo: false

text_close_diagnosis |> 
  filter(distance_cat == "Medium-distance") |> 
  arrange(-n) |> 
  select(diagnosis, n) |> 
  filter(n > quantile(n, probs = 0.8)) |> 
  knitr::kable(caption ="Medium Distance") 
```

```{r}
#| code-summary: "Diagnosis reason (long)"
#| echo: false

text_close_diagnosis |> 
  filter(distance_cat == "Long-distance") |> 
  arrange(-n) |> 
  select(diagnosis, n) |> 
  filter(n > quantile(n, probs = 0.8)) |> 
  knitr::kable(caption ="Long Distance") 
```

From the table, the dispatch and diagnosis reasons seem to point to the same thing, which is that for the shorter distance, the reason seems to be about the injuries that require quick transfer, while the medium to long-distance suggests mental health issues. It is expected that the emergency transfer that requires quick attention should be done quickly.


```{r}
#| code-summary: "Visualisation"
#| label: fig-distance-dis-nozero
#| echo: false
patient_dist |>
  filter(distance != 0) |>
  ggplot(aes(x = distance + 1)) +
  geom_histogram(bins = 45) +
  scale_x_log10() +
  facet_wrap(~routine, scale = "free_y", ncol = 1) +
  labs(y = "Count", x = "Distance (log-scale)")
```


# Project 2: Dynamics Infectious Disease Modelling using a Generalised Ambulance Model

This project focuses on understanding the impact of any changes in the ambulance transfer network affect the spread of infectious diseases, particularly among older populations in residential aged care facilities (RACFs). Ambulance transfer create a way in which infections can be transmitted throughout facilities and hospitals. Variations in transfer demand, routing strategies, or operational constraints can alter the structure of the network and, in turn, influence outbreak dynamics.

Infectious disease dynamics describe how the disease is spread and evolves within the population over time. These dynamics depend on the contact between individuals or groups, movement between locations, and the timing of infection and recovery. Traditional compartmental models, such as susceptible-infectious-recovered (SIR) or susceptible-exposed-infectious-recovered (SEIR), are often used to represent the disease progression within and between groups.

To capture the interaction between ambulance demand, transfer allocation, and infectious disease transmission on a dynamic network, this project proposes a three-step modelling framework.

Step 1: Modelling Ambulance Demand

Ambulance demand is modelled using a spatio-temporal point process, where each event represents a case requiring transfer between a residential aged care facility and hospital [@zhou2015spatio].

Step 2: Ambulance Allocation and Network Construction

Given the simulated demand, a deterministic or stochastic allocation method is applied to determine how calls are distributed across hospitals in Victoria. The real-world transfer patterns are observed through exploratory data analysis of the collected transfer data. The transfer allocation defines a network linking RACFs and hospitals.

Step 3: Infectious Disease Dynamics on the Transfer Network

The generated ambulance transfer network is then used as input to an infectious disease transmission model. It allows the disease to spread within facilities (RACFs and hospitals) and between the facilities through ambulance transfers.


# Timeline



# References
