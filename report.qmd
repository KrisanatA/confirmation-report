---
title: "Visual methods for exploring multivariate spatio-temporal networks with application to health transport"
subtitle: "Confirmation Report"
author: "Krisanat Anukarnsakulchularp"
format: 
  html:
    toc: true
bibliography: report.bib
---

```{r}
#| message: false
#| echo: false
#| warning: false

# library
library(tidyverse)
library(ggplot2)
library(tidygraph)
library(ggraph)
library(sfnetworks)
library(sf)
library(ggiraph)
library(tsibble)
library(gghighlight)
library(ggthemes)

theme_set(
  theme_minimal()
)

options(scipen = 999)

pal_colorblind <- colorblind_pal()(8)[2:8]
```

```{r}
#| output: false
#| echo: false

# read data
address <- read_csv(here::here("data/ambulance/hospital_address.csv"))

hos_list <- read_csv(here::here("data/ambulance/Hospital_list.csv")) |>
  janitor::clean_names() |>
  rename(name = other_name) |>
  mutate(name = toupper(name))

patient <- read_csv(here::here("data/ambulance/patient_clean.csv")) |>
  select(!c(...1, ...2)) |>
  mutate(routine = ifelse(routine == 1, "Scheduled", "Emergency")) |>
  filter(iht != 1)

racf <- read_csv(here::here("data/ambulance/RACF_address.csv"))

transfers <- read_csv(here::here("data/ambulance/transfers_all.csv")) |>
  select(!...1)

vic_map <- read_sf(here::here("data/map/LGA_2025_AUST_GDA2020/LGA_2025_AUST_GDA2020.shp")) |>
  filter(STE_NAME21 == "Victoria")
```

```{r}
#| echo: false
racf_location <- transfers |>
  select(sceneaddress, long_racf, lat_racf) |>
  distinct() |>
  rename(long = long_racf,
         lat = lat_racf,
         name = sceneaddress) |> 
  mutate(type = "racf")

hospital_location <- transfers |>
  select(hospitalname, long_hosp, lat_hosp) |>
  distinct() |>
  rename(long = long_hosp,
         lat = lat_hosp,
         name = hospitalname) |> 
  mutate(type = "hospital")

full_location <- bind_rows(racf_location, hospital_location)

simple_graph <- transfers |>
  rename(from = sceneaddress,
         to = hospitalname) |>
  as_tbl_graph() |>
  left_join(full_location, by = "name") |>
  mutate(category = ifelse(name %in% transfers$sceneaddress, "racf", "hospital"))
```

# Background {#sec-background}

Analysing spatio-temporal network data is a contemporary research problem that has gained increasing interest in the health field, particularly within emergency medical services (EMS) and ambulance transfer systems.Â  Such data capture spatial, temporal, and often multivariate information. The spatial component generally represents geographic locations or spatial geometries, while the temporal component records time-related information through timestamps or time intervals [@rao2012spatiotemporal]. In addition, the underlying network structure creates connections and multivariate dependencies between locations and transfers. While techniques exist to analyse spatial and temporal components separately, performing analysis, and perhaps more importantly, exploring these components in conjunction with the network structure, remains an open challenge.

Older individuals often require continuous support, including 24-hour care, assistance with daily tasks, and ongoing medical supervision. Thus, many reside in the residential aged care facilities (RACFs), which are specifically designed to provide this comprehensive care [@kearney2006nearby]. RACFs frequently rely on the ambulance services to facilitate the transfers of an individual to the hospital for both acute emergencies and planned/scheduled medical appointments. This rise in the number of transfers is partly due to population ageing [@harris2018estimating], which puts incredible pressure on emergency medical services, where delay could lead to an increase in health risk [@harmsen2015influence]. During the COVID-19 pandemic, lockdown measures and movement restrictions further disrupted the delivery of emergency services. The effects of lockdowns and rising transfer demand highlight the need for further analysis to improve the planning and utilisation of ambulance services.

To gain insight into transfer patterns, data exploration using network representations linking RACFs and hospitals provides a powerful framework. However, most network research focuses primarily on topological properties, often treating them homogeneously and overlooking other important information, such as the association between variables [@cardenas2021spatio; @fernandez2017influence]. While network representation is suited to transfer data, overemphasising network topology can neglect the fundamental principles of data exploration. These limitations arise from the practical challenges of working with spatio-temporal network data, including data cleaning methods, particularly temporal information, the ease of data wrangling and subsetting, and the challenges of visualisation and inference. As a result, simple informative analyses, such as examining variable distributions, temporal trends, or bivariate relationships, are often underutilised, despite the ability to reveal key insights of the data. This underlines the need for an infrastructure that integrates network-based approaches with exploratory data analysis (EDA), enabling a comprehensive exploration of spatio-temporal transfer networks.

Studying how infectious diseases spread throughout the network (transfer between RACFs and hospitals) is important because the older population tend to face a higher risk of mortality during the outbreaks [@parohan2020risk]. These patient transfers between facilities create ways for the disease to be transmitted across the systems, leading to rapid spread. Traditional compartmental infectious disease models assuming homogeneous or static structure do not adequately capture networks that change over time. In reality, ambulance transfers are highly dynamic, where these connections between facilities can change in response to the demand, constraints, and even outbreak conditions. Understanding these transmission dynamics is therefore crucial for devising effective policies to limit spread as well as identify high-risk facilities, critical transfer connections, and exposed periods.


# Project 1: Developing Infrastructure for Exploratory Analysis of Multivariate Spatio-temporal Network with Application to Ambulance Transfers

## Part A: Exploratory Data Analysis Infrastructure for Multivariate Spatio-temporal Network

As multivariate spatio-temporal network data become more accessible and complex, understanding their structure and dynamics is key to effective decision-making. As mentioned in @sec-background, a major challenge in analysing large multivariate networks lies in the sheer amount of information it contains, most of which is often overlooked. This infrastructure aims to support the exploration of multivariate spatio-temporal network data. The exploratory data analysis involves several key processes: data storage, cleaning, subsetting, and visualisation. The following section, therefore, reviews existing tools that support these processes and discusses their limitations.


### Data Storage and Cleaning

Data cleaning is the first stage of a reliable analysis. Spatio-temporal data usually need to be checked for inconsistency of the temporal records, duplicated records, and spatial inaccuracies. Now, adding the network structure on top of that, such as nodes, edges, and their attributes, requires the network topology to be kept throughout the process. Typically, this stage involves tools such as `dplyr` [@dplyr] for manipulating the data, `tsibble` [@tsibble] for validating the temporal inconsistency, `sf` [@sf] for checking the coordinate inaccuracies, and `igraph`/`network` [@igraph; @network] for keeping the network structure.

The `tidygraph` [@tidygraph] package provides a tidy API for graph and network manipulation, where network data is thought of as two tidy tables, one for node and one for edge data. In tidy data [@tidy-data], each variable has its own column, each observation has its own row, and each value has its own cell. These tables are then stored together within a `tbl_graph` object, which preserves the underlying network topology while allowing standard `dplyr` verbs to be applied. The interaction between node and edge tables is done through the use of a special function, `activate()`, which allows the user to switch between the two tables and apply `dplyr` operations such as `mutate()`, `group_by()`, and join operations.

There are two main functions for creating `tbl_graph` object, `as_tbl_graph()` and `tbl_graph()`. The first function `as_tbl_graph()` takes in a different class of objects, such as `data.frame`, `igraph`, and `network`, then turns it into a `tbl_graph` object. While `tbl_graph()` takes in two `data.frame` objects, one for node and one for edge.

The difference between these two methods is that for the `as_tbl_graph()` function, it only needs the edges dataset, which means that all the multivariate information will only be on edge data and in the node data, it will only have the name (location). For the `tbl_graph()` function, the node variable can be explicitly stated, which can come in handy when there are attributes on the node dataset.

```{r}
#| echo: false
racf_nodes <- transfers |> 
  distinct(sceneaddress, long_racf, lat_racf) |>
  rename(name = sceneaddress,
         longitude = long_racf,
         latitude = lat_racf) |> 
  mutate(type = "racf")

hospital_nodes <- transfers |>
  distinct(hospitalname, long_hosp, lat_hosp) |>
  rename(name = hospitalname,
         longitude = long_hosp,
         latitude = lat_hosp) |>
  mutate(type = "hospital")

nodes <- bind_rows(racf_nodes, hospital_nodes)

edges <- patient |>
  rename(from = sceneaddress,
         to = hospitalname) |>
  select(from, to, casedate, age, gender, diagnosis, daytype, single_id)

graph <- tbl_graph(nodes, edges) |>
  activate(edges) |>
  mutate(year = lubridate::year(casedate))
```

```{r}
#| eval: false
as_tbl_graph(edges)

tbl_graph(nodes, edges)

graph |>
  activate(edges) |>
  mutate(year = lubridate::year(casedate))
```

```{r}
#| echo: false
tbl_graph(nodes, edges) |>
  activate(edges) |>
  mutate(year = lubridate::year(casedate))
```

For spatial networks, the `sfnetworks` package [@sfnetworks] extends `tidygraph` by allowing spatial geometries to be incorporated directly within the `tbl_graph` object. It is useful for dealing with complex geometry where edges are not straight-line connections, such as road or transport networks. The package also allows for the standard spatial operation within the `sf` package to be performed within the network context. 

However, the temporal data structure provided by `tsibble` is not directly compatible with `tidygraph` objects. As a result, validating temporal consistency requires converting data back to a `tsibble` object or performing a temporal check prior to the creation of `tbl_graph`. It introduces an important limitation, where common operations of filling missing observations are done outside the network context and therefore do not preserve the network topology. For example, if a node is missing in January 2020, how should the edges associated with that node be imputed? A sensible solution is to assume no edges exist during that period, which is reasonable in some cases but not in all cases. It highlights a key challenge in cleaning spatio-temporal network data, where temporal consistency and network structure should be considered jointly. The challenges require careful methodological decisions to ensure that both temporal attributes and the relational structure of the network remain coherent throughout the cleaning process.


### Data Subsetting {#sec-datasubsetting}

Data subsetting is used to extract a subset of spatio-temporal network data based on spatial, temporal, and multivariate variables. This includes grouping data by time periods or regions, as well as filtering based on variable values and network characteristics (e.g., in-degree). In a network context, filtering operations need to account for topological dependencies between nodes and edges. When nodes are removed based on a condition, all edges incident to those nodes are also deleted (@fig-node-filter). In contrast, when edges are removed, the nodes connected to those edges are preserved, since nodes can exist independently from an edge (@fig-edge-filter). The `tidygraph` supports these subsetting operations through the use of `dplyr` functions such as `filter()` and `select()`, which are applied separately on nodes and edges while maintaining the condition of the underlying network. Similarly to the data manipulation, users will need to switch between the node and edge tables to subset based on their attributes.

```{r}
#| echo: false
nodes_example <- tibble(name = c(1, 2, 3, 4, 5),
                        x = c(1, 1.5, 2, 2, 3),
                        y = c(2, 1, 2, 3, 1))

edges_example <- tibble(from = c(1, 1, 2, 3, 3),
                        to = c(2, 3, 3, 4, 5))

graph_example <- tbl_graph(nodes = nodes_example, edges = edges_example, directed = FALSE)
```

```{r}
#| label: fig-node-filter
#| layout-ncol: 3
#| echo: false
#| fig-cap: "Node filtering"
#| fig-subcap:
#|  - "Full network"
#|  - "Node to remove"
#|  - "Filtered network"

graph_example |> 
  ggraph(x = x, y = y) + 
  geom_edge_link() +
  geom_node_point(size = 10, color = "blue")

graph_example |> 
  mutate(check = as.factor(ifelse(name == "5", 1, 0))) |> 
  ggraph(x = x, y = y) +
  geom_edge_link() +
  geom_node_point(aes(color = check), size = 10) +
  scale_color_manual(values = c("blue", "red")) +
  theme(legend.position = "none")
  
graph_example |> 
  mutate(check = as.factor(ifelse(name == "5", 1, 0))) |> 
  activate(edges) |> 
  mutate(check = as.factor(ifelse(to == "5", 1, 0))) |> 
  ggraph(x = x, y = y) +
  geom_edge_link(aes(color = check)) +
  geom_node_point(aes(color = check), size = 10) +
  scale_color_manual(values = c("blue", "white")) +
  scale_edge_color_manual(values = c("black", "white")) +
  theme(legend.position = "none")
```

```{r}
#| label: fig-edge-filter
#| layout-ncol: 3
#| echo: false
#| fig-cap: "Edge filtering"
#| fig-subcap:
#|  - "Full network"
#|  - "Edges to remove"
#|  - "Filtered network"

graph_example |> 
  ggraph(x = x, y = y) + 
  geom_edge_link(color = "blue") +
  geom_node_point(size = 10)

graph_example |> 
  activate(edges) |> 
  mutate(check = as.factor(ifelse(to %in% c("4", "5"), 1, 0))) |> 
  ggraph(x = x, y = y) +
  geom_edge_link(aes(color = check)) +
  geom_node_point(size = 10) +
  scale_color_manual(values = c("blue", "red")) +
  scale_edge_color_manual(values = c("blue", "red")) +
  theme(legend.position = "none")

graph_example |> 
  activate(edges) |> 
  mutate(check = as.factor(ifelse(to %in% c("4", "5"), 1, 0))) |> 
  filter(check != 1) |> 
  ggraph(x = x, y = y) +
  geom_edge_link(color = "blue") +
  geom_node_point(size = 10) +
  theme(legend.position = "none")
```

```{r}
graph |>
  activate(edges) |>
  filter(between(year, 2020, 2021))
```


### Network Sampling

Another important aspect of subsetting is understanding how sampling methods perform on network data. Real-world datasets are often not evenly distributed across multiple dimensions such as time, space, or variable groups. Some strata may contain more observations than others, and analysing these can directly impact the interpretation, as the larger group of strata may dominate the patterns seen. Sampling provides a way to subset the data while keeping it representative of the population. Stratified sampling, inparticular, helps with an imbalance case by dividing the data into subgroups and sampling within each group, ensuring that all groups are represented in the sampled data.

<!--Add diagraph-->

In the network context, sampling methods are generally categorised into the following [@chuong2025network]:

  - **Node-based sampling** selects a subset of nodes from the network and retains edges that are incident to the sampled nodes. This method is efficient and is usually implemented in large-scale studies [@ben2022sampling]. It often fails to capture important global structural properties such as connectivity and clustering.

  - **Edge-based sampling** samples a subset of edges directly and includes the nodes incident to those edges. This method is better at preserving structural pattern [@jiao2024sampling]. However, it may introduce bias towards selecting nodes with higher degrees, resulting in biased sampled data.

There are many additional methods for sampling. @hu2013survey provides a comprehensive survey and taxonomy of graph sampling approaches, which are outside the scope of this project.

The `tidygraph` package provides a method for sampling the data for a `tbl_graph` object through a `sample_n()` function, although it is now recommended to use `slice_sample()` instead. A further limitation of the `tbl_graph` is that it does not directly support stratified (i.e., `group_by`) sampling. Instead, the `tbl_graph` object needs to be converted back to `tibble` [@tibble], performing stratified sampling on the node or edge table, and then filtering the original network based on the sampled nodes or edges. This limitation shows that sampling operations for network objects can still be improved.

```{r}
#| message: false
#| eval: false
set.seed(1)

# Edges sampling
graph |> 
  activate(edges) |> 
  sample_n(size = 20)

# Stratified edges sampling
edges_kept <- graph |> 
  activate(edges) |> 
  as_tibble() |> 
  group_by(daytype) |> 
  sample_n(size = 10) |> 
  pull(single_id)

graph |> 
  activate(edges) |> 
  filter(single_id %in% edges_kept) |> 
  activate(nodes) |> 
  filter(!node_is_isolated())
```

```{r}
#| echo: false

edges_kept <- graph |>
  activate(edges) |>
  as_tibble() |>
  group_by(daytype) |>
  sample_n(size = 10) |>
  pull(single_id)

graph |>
  activate(edges) |>
  filter(single_id %in% edges_kept) |>
  activate(nodes) |>
  filter(!node_is_isolated())
```

As discussed in @sec-datasubsetting, nodes in a network can exist independently without incident edges. Thus, the edge-based sampling does not automatically remove nodes that become isolated after sampling. To remove these nodes, they must be explicitly removed by filtering the node table using the `node_is_isolated()` function.


### Data visualisation

Data visualisation helps reveal patterns, anomalies and relationships that may not be apparent from numerical summaries alone. Network data is often viewed as connections or flows between nodes/locations, and network-based visualisation allows for easier communication to a broader audience. For a simple network without spatial coordinates, placing nodes and edges in a visualisation requires the use of a graph layout algorithm, such as the Kamada-Kawai layout [@kk]. Depending on the chosen algorithm, the positions of nodes and edges can be different even on the same network dataset. With spatial information, visualising these becomes more straightforward, as longitude and latitude can be used to specify the actual location of the nodes, with edges represented as lines connecting these locations.

```{r}
#| label: fig-static-network
#| fig-cap: "An ambulance transfers network in Victoria between residential aged care facilities and hospitals."
#| code-summary: "Visualisation"

simple_graph |> 
  ggraph(x = long, y = lat) +
  geom_sf(data = vic_map, color = "white") +
  geom_edge_link(alpha = 0.1) +
  geom_node_point(aes(color = category))
```

Visualising high-dimensional network data can be challenging, especially through a static visualisation alone. The current tool for network visualisation in R is the `ggraph` package [@ggraph], which extends the `ggplot2` package [@ggplot2] to support relational data structures such as networks, graphs, and trees. The `ggraph` package is effective at visualising static networks, offering a range of layout algorithms for placing the node locations while keeping the same familiar `ggplot2` syntax. The support for interactive network visualisation with `ggraph` is currently limited. The reason static network visualisation is hard is that the amount of information that can be mapped to the visualisation is limited within a single figure. As shown in @fig-static-network, just a simple network representation can already become cluttered quickly. Answering detailed questions such as the number of transfers between a specific RACF and Hospital, or the name of a particular RACF, is difficult using static visualisation alone. Interactive visualisation help with these limitation by layering additional information onto the visualisation, allowing for further exploration.

```{r}
#| label: fig-interact-node
#| fig-cap: "An ambulance transfers network in Victoria between residential aged care facilities and hospitals with an interactive node."
#| code-summary: "Visualisation"
interactive_vis_node <- simple_graph |> 
  mutate(name = str_remove(name, "'")) |> 
  ggraph(x = long, y = lat) +
  geom_sf(data = vic_map, color = "white") +
  geom_edge_link(alpha = 0.1) +
  geom_point_interactive(aes(x = x, 
                             y = y,
                             color = category,
                             tooltip = name,
                             data_id = name))

girafe(ggobj = interactive_vis_node,
       options = list(
         opts_hover(css = "fill:lightblue;stroke:grey;stroke-width:0.5px"),
         opts_zoom(min = 0.5, max = 3)
       ))
```

```{r}
#| label: fig-interact-edge
#| fig-cap: "An ambulance transfers network in Victoria between residential aged care facilities and hospitals with an interactive edge."
#| code-summary: "Visualisation"

interactive_vis_edge <- simple_graph |> 
  ggraph(x = long, y = lat) +
  geom_sf(data = vic_map, color = "white") +
  geom_node_point(aes(color = category)) +
  geom_segment_interactive(
    data = simple_graph |> activate(edges) |> as_tibble() |> mutate(id = row_number()),
    alpha = 0.2,
    aes(x = long_racf,
        y = lat_racf,
        xend = long_hosp,
        yend = lat_hosp,
        tooltip = weight,
        data_id = id))
  

girafe(ggobj = interactive_vis_edge,
       options = list(
         opts_hover(css = "fill:lightblue;stroke:grey;stroke-width:0.5px"),
         opts_zoom(min = 0.5, max = 3)
       ))
```

The `ggiraph` package [@ggiraph] provides an interactive element to the visualisation through the `ggplot2` extension. Creating interactive network visualisations, therefore, typically requires combining `ggraph` for layout construction with `ggiraph` for interactivity. Getting this to work together requires an insight into how `ggraph` works, which is not a seamless implementation. For example, `ggraph` provides `geom_node_*` and `geom_edge_*` functions for nodes and edges geometry, respectively, but these do not natively support interactivity. To make nodes interactive, `geom_point_interactive()` need to be use instead of `geom_node_point()`. Making edges interactive is more complex as it requires the use of `geom_segment_interactive()` and mapping the start and end coordinates (`x`, `y`, `xend`, `yend`) for each edge. By that point, if both node and edge need interactivity, then `ggraph` is not needed, and instead the node and edge can be treated as a different dataset and implement geom_point and geom_segment for drawing the node and edge.


### Visual Inference


## Part B: Exploratory Analysis of Ambulance Demand and Efficiency

The efficiency of the ambulance transfer is critical in both scheduled and emergency transfer cases to minimise the resources used and affect the patient outcomes. In scheduled transfers, the longer the transfer, the fewer ambulances are available in the system, which potentially limits the number of ambulances available during the peak demand or emergency state. In emergency transfers, it directly influences the outcomes of the patient, especially for time-sensitive conditions such as trauma, cardiac emergencies, and stroke. Analysing ambulance transfer efficiency is therefore crucial for improving the quality of emergency care, ensuring an adequate number of available ambulances, and strengthening the system. In addition, predicting ambulance demand is also important as it allows the services to plan accordingly in different scenarios (e.g. peak demand).

The ambulance transfer data was provided by Alfred Health. The dataset included the following aspects: spatial, temporal, and multivariate information on each transfer. The spatial covers the location of the aged care facilities and the hospital (destination) in latitude and longitude. While the temporal provides the date of the transfers, which cover the period between January 2018 and May 2022. For multivariate information, it covers hospitals, aged care facilities, and patient-level details.


### Efficiency

The efficiency of the ambulance transfer is critical in both the case of scheduled and emergency transfer to minimise the use of resources. In the schedules service, the longer the transfer, the fewer ambulances are avaiable in the system, which poentially limits the number of ambulances available during an emergency state. For the emergency case, it directly influences the outcomes of the patient, espcially for time sensitive consitions such as trauma, cardiac emergencies, and stroke. The analysis of the ambulance transfer is therefore crucial for improving the quality of emergency care, ensuring an adequate number of available ambulances, and strengthening the system.

Measuring efficiency can be done in many ways; one of the proxies that can be used for estimating these is the distance from the aged care facilities to hospital. The haversine distance is one that takes into account the curvature of the Earth. However, given the area covered by the dataset, the Euclidean distance will be used instead. It calculates the shortest distance between two points using the latitude and longitude. This measure should give a reasonable estimate for less computing compared to the actual road distance. Note that the limitation is that it ignores the actual street network distance, which is not a straight line, and therefore, the distance between the RACF and the hospital will generally be longer.

```{r}
#| code-summary: "Calculate distance"
#| echo: false
racf_sf <- patient |> 
  select(-c(hospitalname, long_hosp, lat_hosp)) |> 
  st_as_sf(coords = c("long_racf", "lat_racf"), crs = st_crs(4326)) |> 
  rename(geometry_racf = geometry)

hosp_sf <- patient |> 
  select(hospitalname, long_hosp, lat_hosp) |> 
  st_as_sf(coords = c("long_hosp", "lat_hosp"), crs = st_crs(4326)) |> 
  rename(geometry_hosp = geometry)

patient_dist <- bind_cols(racf_sf, hosp_sf) |> 
  mutate(distance = st_distance(geometry_racf, geometry_hosp, by_element = TRUE),
         distance = as.double(distance))
```

```{r}
#| code-summary: "Visualisation"
#| label: fig-distance-dis
#| echo: false
patient_dist |>
  ggplot(aes(x = distance + 1)) +
  geom_histogram(bins = 45) +
  facet_wrap(~routine, scales = "free_y", ncol = 1) +
  scale_x_log10() +
  labs(y = "Count", x = "Distance (log-scale)")
```

```{r}
#| echo: false

dist_dis <- patient_dist |>
  filter(distance != 0) |>
  pull(distance)
```

From @fig-distance-dis, there seems to be zero distance transfer in the data, which might suggest either a data entry error or that the aged care facilities and hospital are next to each other. In the latter case, this might suggest that it may not need the ambulance to transfer the patient. After filtering the distance data to zero and manually going through them, it can be seen that the location of the aged care facility and hospital is, in fact, the same location. 

In an emergency case, it is important that the transfer is done quickly. It means that most of the time, the RACF that is right next to the hospital should not have a patient transferred to another hospital. One thing that will need to be considered is that the hospital, which is right next to the RACF, might not be able to handle the emergency case. In this case, the patient should be transferred to another emergency-capable hospital. This information can be verified through the hospital data, which has a column indicating whether the hospital has an emergency department or not.

Based on this information, the efficiency can be improved through fewer transfers to the other hospital that is further away, especially the RACF, whose location is right next to the hospital. To check this, the distance is calculated between the RACF and hospital for all the possible combinations to see which RACF is next to which hospital.

```{r}
#| code-summary: "Calculate all combination distance"
#| echo: false
racf_list <- racf |>
  mutate(name = paste(location_address, suburb, " ")) |>
  select(name, longitude, latitude)

hosp_list <- hos_list |>
  left_join(patient |> select(hospitalname, long_hosp, lat_hosp),
            by = c("name" = "hospitalname")) |>
  rename(hospitalname = name) |> 
  distinct(hospitalname, long_hosp, lat_hosp) |> 
  na.omit()

combination_list <- expand_grid(racf_list, hosp_list)

combi_racf_sf <- combination_list |> 
  select(name, longitude, latitude) |>
  st_as_sf(coords = c("longitude", "latitude"), crs = st_crs(4326)) |> 
  rename(geometry_racf = geometry)

combi_hosp_sf <- combination_list |> 
  select(hospitalname, long_hosp, lat_hosp) |> 
  st_as_sf(coords = c("long_hosp", "lat_hosp"), crs = st_crs(4326)) |> 
  rename(geometry_hosp = geometry)

all_distance <- bind_cols(combi_racf_sf, combi_hosp_sf) |> 
  mutate(distance = st_distance(geometry_racf, geometry_hosp, by_element = TRUE),
         distance = as.double(distance))
```

```{r}
#| code-summary: "RACF close to hospital"
#| echo: false
close <- all_distance |>
  filter(distance == 0) |>
  distinct(name) |>
  pull(name) |>
  trimws()
```

```{r}
#| code-summary: "Dispatch reason"
#| echo: false
patient_dist <- patient_dist |>
  mutate(check = ifelse(sceneaddress %in% toupper(close), "Close", "Far"))

patient_dist |>
  filter(check == "Close") |>
  count(dispatch, sort = TRUE) |>
  st_drop_geometry() |>
  filter(n > quantile(n, probs = 0.95)) |>
  knitr::kable(caption = "RACF that is close to hospital")

patient_dist |>
  filter(check == "Far") |>
  count(dispatch, sort = TRUE) |>
  st_drop_geometry() |>
  filter(n > quantile(n, probs = 0.95)) |>
  knitr::kable(caption = "RACF that is far from hospital")
```

```{r}
#| code-summary: "Visualisation"
#| label: fig-distance-dis-close
#| echo: false
patient_dist |>
  ggplot(aes(x = distance + 1)) +
  geom_histogram(bins = 45) +
  facet_wrap(~check + routine, scales = "free_y", ncol = 2) +
  scale_x_log10() +
  labs(y = "Count", x = "Distance (log-scale)")
```

The expectation of the transfer distance for the RACF that is close to the hospital would be, on average, less than that of the other case. However, from @fig-distance-dis-close, it can be seen that, on average, the transfer distance for the RACF that is next to the hospital is higher. It actually raises more questions about why this is the case.

```{r}
#| code-summary: "Visualisation"
#| label: fig-racf-close-net
#| echo: false
simple_graph |>
  activate(edges) |>
  mutate(from_name = .N()$name[from]) |>
  filter(from_name %in% toupper(close)) |>
  activate(nodes) |>
  filter(!node_is_isolated()) |>
  ggraph(x = long, y = lat) +
  geom_sf(data = vic_map, color = "white") +
  geom_edge_link(alpha = 0.1) +
  geom_node_point(aes(color = category)) +
  scale_color_manual(values = c("grey", "blue"))
```

```{r}
#| code-summary: "Visualisation"
#| label: fig-racf-close-point
#| warning: false
#| echo: false
simple_graph |>
  filter(category == "racf") |>
  ggraph(x = long, y = lat) +
  geom_sf(data = vic_map, color = "white") +
  geom_node_point(color = "red") +
  gghighlight(name %in% toupper(close))
```

From @fig-racf-close-net, it can be observed that a lot of patients got transferred from the regional to the Melbourne area. Though visualising this can be hard on the map because the Melbourne area is smaller than the regional area, therefore, a lot of points inside the Melbourne area will get squished together, which makes it hard to visualise. One of the solutions is to group the hospitals within Melbourne together by their emergency capabilities.

```{r}
#| code-summary: "Grouping melbourne hospital"
#| echo: false
hospital_melbourne <- hospital_location |>
  mutate(classification = ifelse(between(lat, -38.5, -37.5) &
                                 between(long, 144.5, 145.5),
                               "melbourne",
                               "regional")) |>
  filter(classification == "melbourne") |>
  pull(name)

hospital_emergency <- hos_list |>
  filter(emergency_capable == "YES") |>
  pull(name)

simulate_location <- tibble::tibble(name = c("MELBOURNE HOSPITAL EMERGENCY",
                                             "MELBOURNE HOSPITAL NON EMERGENCY"),
                                    long = c(144.75, 145.25),
                                    lat = c(-38, -38))

full_location <- bind_rows(full_location, simulate_location)

simple_group_graph <- transfers |>
  mutate(hospitalname = case_when(
                                  hospitalname %in% hospital_melbourne & 
                                    hospitalname %in% hospital_emergency 
                                  ~ "MELBOURNE HOSPITAL EMERGENCY",
                                  hospitalname %in% hospital_melbourne & 
                                    !(hospitalname %in% hospital_emergency) 
                                  ~ "MELBOURNE HOSPITAL NON EMERGENCY",
                                  .default = hospitalname
                                  )) |>
  rename(from = sceneaddress,
         to = hospitalname) |>
  as_tbl_graph() |>
  left_join(full_location, by = "name") |>
  mutate(category = case_when(
                              name %in% transfers$sceneaddress ~ "RACF",
                              name == "MELBOURNE HOSPITAL EMERGENCY" 
                              ~ "Melbourne Emergency",
                              name == "MELBOURNE HOSPITAL NON EMERGENCY" 
                              ~ "Melbourne Non Emergency",
                              .default = "Regional Hospital"
                              ),
         category = factor(category, 
                           levels = c("Melbourne Emergency", 
                                      "Melbourne Non Emergency", 
                                      "Regional Hospital", 
                                      "RACF"))
         )
```

```{r}
#| code-summary: "Visualisation"
#| echo: false
#| label: fig-group-close-net-spatial
simple_group_graph |>
  activate(edges) |>
  mutate(from_name = .N()$name[from]) |>
  filter(from_name %in% toupper(close)) |>
  activate(nodes) |>
  filter(!node_is_isolated()) |>
  ggraph(x = long, y = lat) +
  geom_sf(data = vic_map, color = "white") +
  geom_edge_link(alpha = 0.1) +
  geom_node_point(aes(color = category)) +
  theme(legend.position = "bottom") +
  scale_color_manual(values = pal_colorblind[1:4])
```

```{r}
#| code-summary: "Visualisation"
#| label: fig-group-close-net-free
#| echo: false
simple_group_graph |>
  activate(edges) |>
  mutate(from_name = .N()$name[from]) |>
  filter(from_name %in% toupper(close)) |>
  activate(nodes) |>
  filter(!node_is_isolated()) |>
  ggraph(layout = "stress") +
  geom_edge_link(alpha = 0.3) +
  geom_node_point(aes(color = category)) +
  theme(legend.position = "bottom") +
  scale_color_manual(values = pal_colorblind[1:4])
```

The question is why these RACFs, which are right next to the hospital, have to transfer the patient to the hospital that is further away. From the summarising process, there is a repeated distance which might suggest that there is a common hospital that RACF likes to use, or there might be a common symptom that this is the closest hospital that can treat it.


#### Transfer Distance

To further analyse the common reason for the patient transfer (RACF next to Hospital), the transfer distance will be grouped into the following;

- Zero distance (RACF and Hospital that is co-located)

- Between 0 and 10km (Short-distance)

- Between 10km and 50km (Medium-distance)

- Above 50km (Long-distance)


##### Dispatch Reason

```{r}
#| code-summary: "Grouping distance"
#| echo: false
patient_dist <- patient_dist |>
  mutate(distance_cat = case_when(
                          distance == 0 ~ "Zero",
                          between(distance, 1, 10000) ~ "Short-distance",
                          between(distance, 10000, 50000) ~ "Medium-distance",
                          distance > 50 ~ "Long-distance"
                                  ),
         distance_cat = factor(distance_cat,
                               levels = c("Zero", "Short-distance",
                                          "Medium-distance", "Long-distance")))
```

```{r}
#| code-summary: "Count the dispatch reason (RACF next to hospital)"
#| echo: false
text_close_dispatch <- patient_dist |> 
  st_drop_geometry() |> 
  filter(sceneaddress %in% toupper(close),
         routine == "Emergency") |> 
  count(distance_cat, dispatch)
```

```{r}
#| code-summary: "Dispatch reason (zero)"
#| echo: false

text_close_dispatch |> 
  filter(distance_cat == "Zero") |> 
  arrange(-n) |> 
  select(dispatch, n) |> 
  filter(n > quantile(n, probs = 0.8)) |> 
  knitr::kable(caption ="Zero Distance") 
```

```{r}
#| code-summary: "Dispatch reason (short)"
#| echo: false

text_close_dispatch |> 
  filter(distance_cat == "Short-distance") |> 
  arrange(-n) |> 
  select(dispatch, n) |> 
  filter(n > quantile(n, probs = 0.8)) |> 
  knitr::kable(caption ="Short Distance") 
```

```{r}
#| code-summary: "Dispatch reason (medium)"
#| echo: false

text_close_dispatch |> 
  filter(distance_cat == "Medium-distance") |> 
  arrange(-n) |> 
  select(dispatch, n) |> 
  filter(n > quantile(n, probs = 0.8)) |> 
  knitr::kable(caption ="Medium Distance") 
```

```{r}
#| code-summary: "Dispatch reason (long)"
#| echo: false

text_close_dispatch |> 
  filter(distance_cat == "Long-distance") |> 
  arrange(-n) |> 
  select(dispatch, n) |> 
  filter(n > quantile(n, probs = 0.8)) |> 
  knitr::kable(caption ="Long Distance") 
```



##### Diagnosis Reason

```{r}
#| code-summary: "Count the diagnosis reason (RACF next to hospital)"
#| echo: false
text_close_diagnosis <- patient_dist |> 
  st_drop_geometry() |> 
  filter(sceneaddress %in% toupper(close),
         routine == "Emergency") |> 
  count(distance_cat, diagnosis)
```

```{r}
#| code-summary: "Diagnosis reason (zero)"
#| echo: false

text_close_diagnosis |> 
  filter(distance_cat == "Zero") |> 
  arrange(-n) |> 
  select(diagnosis, n) |> 
  filter(n > quantile(n, probs = 0.8)) |> 
  knitr::kable(caption ="Zero Distance") 
```

```{r}
#| code-summary: "Diagnosis reason (short)"
#| echo: false

text_close_diagnosis |> 
  filter(distance_cat == "Short-distance") |> 
  arrange(-n) |> 
  select(diagnosis, n) |> 
  filter(n > quantile(n, probs = 0.8)) |> 
  knitr::kable(caption ="Short Distance") 
```

```{r}
#| code-summary: "Diagnosis reason (medium)"
#| echo: false

text_close_diagnosis |> 
  filter(distance_cat == "Medium-distance") |> 
  arrange(-n) |> 
  select(diagnosis, n) |> 
  filter(n > quantile(n, probs = 0.8)) |> 
  knitr::kable(caption ="Medium Distance") 
```

```{r}
#| code-summary: "Diagnosis reason (long)"
#| echo: false

text_close_diagnosis |> 
  filter(distance_cat == "Long-distance") |> 
  arrange(-n) |> 
  select(diagnosis, n) |> 
  filter(n > quantile(n, probs = 0.8)) |> 
  knitr::kable(caption ="Long Distance") 
```

From the table, the dispatch and diagnosis reasons seem to point to the same thing, which is that for the shorter distance, the reason seems to be about the injuries that require quick transfer, while the medium to long-distance suggests mental health issues. It is expected that the emergency transfer that requires quick attention should be done quickly.


```{r}
#| code-summary: "Visualisation"
#| label: fig-distance-dis-nozero
#| echo: false
patient_dist |>
  filter(distance != 0) |>
  ggplot(aes(x = distance + 1)) +
  geom_histogram(bins = 45) +
  scale_x_log10() +
  facet_wrap(~routine, scale = "free_y", ncol = 1) +
  labs(y = "Count", x = "Distance (log-scale)")
```


# Project 2: Dynamics Infectious Disease Modelling using a Generalised Ambulance Model

This project focuses on understanding the impact of any changes in the ambulance transfer network affect the spread of infectious diseases, particularly among older populations in residential aged care facilities (RACFs). Ambulance transfer create a way in which infections can be transmitted throughout facilities and hospitals. Variations in transfer demand, routing strategies, or operational constraints can alter the structure of the network and, in turn, influence outbreak dynamics.

Infectious disease dynamics describe how the disease is spread and evolves within the population over time. These dynamics depend on the contact between individuals or groups, movement between locations, and the timing of infection and recovery. Traditional compartmental models, such as susceptible-infectious-recovered (SIR) or susceptible-exposed-infectious-recovered (SEIR), are often used to represent the disease progression within and between groups.

To capture the interaction between ambulance demand, transfer allocation, and infectious disease transmission on a dynamic network, this project proposes a three-step modelling framework.

Step 1: Modelling Ambulance Demand

Ambulance demand is modelled using a spatio-temporal point process, where each event represents a case requiring transfer between a residential aged care facility and hospital [@zhou2015spatio].

Step 2: Ambulance Allocation and Network Construction

Given the simulated demand, a deterministic or stochastic allocation method is applied to determine how calls are distributed across hospitals in Victoria. The real-world transfer patterns are observed through exploratory data analysis of the collected transfer data. The transfer allocation defines a network linking RACFs and hospitals.

Step 3: Infectious Disease Dynamics on the Transfer Network

The generated ambulance transfer network is then used as input to an infectious disease transmission model. It allows the disease to spread within facilities (RACFs and hospitals) and between the facilities through ambulance transfers.


# Timeline



# References


